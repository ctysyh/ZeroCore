# ZeroCore 需求文档（v1.2）

## 一、概述

ZeroCore 是一个以共享内存池为中心、无锁同步、低延迟、高吞吐、可热重载、跨平台的流处理内核引擎，支持音视频、网络封包、传感器数据等实时场景。本文档描述了 ZeroCore v1.2 的接口需求、数据结构及内部实现要求。

---

## 二、系统级接口与数据结构（`zerocore.h`）

### 2.1 核心类型与常量定义

```c
/* 版本信息 */
#define ZC_VERSION_MAJOR 1
#define ZC_VERSION_MINOR 2

/* 基础类型 */
typedef uint32_t zc_writer_id_t;
typedef uint64_t zc_reader_id_t;
typedef uint32_t zc_token_t;
typedef uint64_t zc_time_t;

/* 不透明句柄 */
typedef struct zc_block_handle zc_block_handle_t;
```

### 2.2 配置结构

```c
typedef struct {
    size_t  pool_size;           // 内存池总大小（字节），必须 >= 4MB
    size_t  heartbeat_interval;  // 心跳间隔（纳秒），默认100ms
    bool    enable_cleaner;      // 是否启用清理者线程
    size_t  cleaner_count;       // 清理者线程数
    size_t  cleaner_stride;      // 清理者并行步进偏移（字节）
    size_t  region_count;        // 内存池分区数
    size_t  region_size[8];      // 各区域大小
    char    reserved[64];        // 预留扩展字段，必须清零
} zc_config_t;

typedef struct {
    const char*     name;        // 线程名称（调试用）
    zc_token_t      token;       // Writer: 数据流标识；Reader: 忽略（使用依附的writer token）
    uint64_t        expected_rate_bps; // 预期速率（字节/秒）
    uint64_t        thread_id;   // 系统线程ID（用于CPU亲和性）
} zc_thread_config_t;
```

### 2.3 枚举与错误码

```c
typedef enum {
    ZC_MSG_CLEAN_HINT = 1,
    ZC_MSG_BACKPRESSURE,
    ZC_MSG_JUMP_ALERT,
    ZC_MSG_MISSING_BLOCK,
    ZC_MSG_STREAM_IDLE,
    ZC_MSG_CUSTOM_BASE = 1000
} zc_message_type_t;

typedef enum {
    ZC_OK = 0,
    ZC_ERROR_INVALID_PARAM,
    ZC_ERROR_OUT_OF_MEMORY,
    ZC_ERROR_TIMEOUT,
    ZC_ERROR_NOT_FOUND,
    ZC_ERROR_ALREADY_EXISTS,
    ZC_ERROR_BUSY,
    ZC_ERROR_SHUTDOWN,
    ZC_ERROR_MAX
} zc_result_t;

typedef enum {
    ZC_LOG_ERROR = 0,
    ZC_LOG_WARN,
    ZC_LOG_INFO,
    ZC_LOG_DEBUG,
    ZC_LOG_TRACE
} zc_log_level_t;
```

### 2.4 系统控制接口

| 接口 | 功能说明 |
|------|----------|
| `zc_init` | 初始化引擎，配置内存池、清理者等 |
| `zc_destroy` | 安全销毁引擎，支持强制模式 |
| `zc_soft_restart` | 软重启：重置状态机，保留内存池数据 |
| `zc_update_config` | 热更新部分配置（如心跳间隔、清理者数量） |
| `zc_stats_snapshot` | 获取当前统计快照（原子操作） |
| `zc_set_log_level` | 设置日志级别 |
| `zc_register_hook` | 注册事件钩子（如块分配、回收、跳跃等） |
| `zc_timestamp` | 获取单调递增的系统时间戳（纳秒） |

---

## 三、写入者（Writer）接口

### 3.1 注册与注销

| 接口 | 功能说明 |
|------|----------|
| `zc_writer_register` | 注册写入者，分配 writer_id，绑定 token |
| `zc_writer_unregister` | 注销写入者，释放所有引用块 |

> ✅ 一个写入者只写入一种 token 的数据流

### 3.2 写入流程

| 接口 | 功能说明 |
|------|----------|
| `zc_writer_acquire_block` | 获取空闲块，支持超时 |
| `zc_writer_commit_block` | 提交写入，标记为 USING |
| `zc_writer_cancel_block` | 取消写入，释放块引用 |

### 3.3 消息与心跳

| 接口 | 功能说明 |
|------|----------|
| `zc_writer_send_message` | 发送消息（双缓冲机制） |
| `zc_writer_check_message` | 检查是否有新消息（清理者发来） |
| `zc_writer_send_heartbeat` | 发送心跳，更新工作空间时间戳 |

---

## 四、读取者（Reader）接口

### 4.1 注册与注销

| 接口 | 功能说明 |
|------|----------|
| `zc_reader_register` | 注册读取者，依附于指定 writer，分配 reader_id |
| `zc_reader_unregister` | 注销读取者，释放所有引用块 |

> ✅ reader_id 高32位为 writer_id，低32位为子索引  
> ✅ 一个读取者只读取其依附的 writer 的数据

### 4.2 读取流程

| 接口 | 功能说明 |
|------|----------|
| `zc_reader_poll_block` | 获取下一个可读块（尽力FIFO） |
| `zc_reader_release_block` | 释放块引用，标记已访问 |

### 4.3 消息与心跳

| 接口 | 功能说明 |
|------|----------|
| `zc_reader_send_message` | 发送消息（双缓冲机制） |
| `zc_reader_check_message` | 检查是否有新消息（清理者发来） |
| `zc_reader_send_heartbeat` | 发送心跳，更新工作空间时间戳 |

---

## 五、块句柄访问器

| 接口 | 功能说明 |
|------|----------|
| `zc_block_data` | 获取块内数据指针（跳过header） |
| `zc_block_size` | 获取块大小（用户可用部分） |
| `zc_block_timestamp` | 获取块时间戳（纳秒） |

---

## 六、策略插件接口

### 7.1 清理策略

```c
typedef struct zc_clean_strategy {
    const char* name;
    void (*init)(void* ctx);
    void (*destroy)(void* ctx);
    uint64_t (*select_clean_start)(void* ctx, void* pool);
    bool (*should_merge)(void* ctx, void* header_a, void* header_b);
    uint64_t (*suggest_write_address)(void* ctx, void* pool, zc_writer_id_t writer_id);
    void* ctx;
} zc_clean_strategy_t;
```

### 7.2 分配策略

```c
typedef struct zc_alloc_strategy {
    const char* name;
    void (*init)(void* ctx);
    void (*destroy)(void* ctx);
    uint64_t (*find_free_block)(void* ctx, void* pool, size_t size, zc_writer_id_t writer_id);
    void* ctx;
} zc_alloc_strategy_t;
```

### 7.3 背压策略

```c
typedef struct zc_backpressure_strategy {
    const char* name;
    void (*init)(void* ctx);
    void (*destroy)(void* ctx);
    bool (*should_throttle)(void* ctx, void* pool, zc_stats_t* stats);
    void (*on_throttle)(void* ctx, zc_writer_id_t writer_id);
    void* ctx;
} zc_backpressure_strategy_t;
```

---

## 八、内部数据结构与函数（`zerocore_inner.h`）

### 8.1 内存池与块头部结构

```c
typedef struct {
    atomic_uint state;          // FREE, USING, CLEAN
    zc_token_t token;
    uint64_t timestamp;
    atomic_uint writer_refs;    // 写入者引用位图
    atomic_uint reader_refs;    // 读取者引用位图
    atomic_uint reader_visited; // 读取者访问记录位图
    size_t size;
    size_t next_offset;         // 下一个块的偏移（用于合并）
} zc_block_header_t;

typedef struct {
    void* base_addr;
    size_t total_size;
    size_t block_align;
    zc_block_header_t** headers; // 块头部指针数组
    atomic_uint free_count;
    atomic_uint using_count;
    // ... 其他内部状态
} zc_memory_pool_t;
```

### 8.2 工作空间结构

```c
typedef struct {
    uint64_t last_heartbeat;
    uint64_t cached_offset;
    uint64_t last_jump_dest;
    zc_msg_space_t msg_space;
    // ... 其他线程局部状态
} zc_workspace_t;
```

### 8.3 注册表结构

```c
typedef struct {
    char name[64];
    zc_token_t token;
    uint64_t expected_rate_bps;
    uint64_t thread_id;
    zc_workspace_t* workspace;
} zc_writer_registry_t;

typedef struct {
    zc_writer_id_t writer_id;
    zc_reader_id_t reader_id;
    zc_workspace_t* workspace;
} zc_reader_registry_t;
```

### 8.4 清理者内部状态

```c
typedef struct {
    zc_clean_strategy_t* strategy;
    atomic_bool is_running;
    size_t stride;
    size_t current_offset;
    // ... 其他清理者状态
} zc_cleaner_context_t;
```

### 8.5 消息结构

```c
typedef struct {
    uint32_t version;    // 发送方递增版本号
    uint16_t type;       // zc_message_type_t
    uint16_t length;     // payload 长度
} zc_msg_header_t;

typedef struct {
    _Atomic uint32_t  read_version;
    _Atomic uint32_t  write_version;
    atomic_uintptr_t  msg_buffer;
    atomic_size_t     buffer_size;
    atomic_bool       is_accumulating;
} zc_msg_space_t;
```

### 8.6 内部函数（不应暴露给用户）

| 函数 | 说明 |
|------|------|
| `zc_internal_merge_blocks` | 合并相邻空闲块 |
| `zc_internal_scan_for_missing` | 扫描遗漏块并通知读取者 |
| `zc_internal_handle_backpressure` | 处理背压事件 |
| `zc_internal_update_msg_buffer` | 更新消息双缓冲区 |
| `zc_internal_recycle_msg_buffer` | 回收消息缓冲区 |

---

## 九、总结

### 9.1 主要变更（v1.2）

1.  **ID 结构重构**：写入者ID为32位，读取者ID为64位（高32位为writer_id）
2.  **消息系统双缓冲**：支持无锁消息交换，版本号机制保证顺序
3.  **接口与内部分离**：`zerocore.h` 为公共接口，`zerocore_inner.h` 为内部实现
4.  **面向接口设计**：接口分类更清晰，便于未来面向对象封装

### 9.2 注意事项

- 所有原子操作需严格指定内存序（`memory_order_acquire`/`release`）
- 内部结构不应暴露给用户，仅通过接口访问
- 双缓冲消息机制需保证版本号原子递增与缓冲区切换的原子性

---
