# ZeroCore Internal 需求文档（v1.3）

---

## 一、共享结构

### 1.1 内存池结构

```c
typedef struct {
    char* name;            // 名称
    atomic_uintptr_t pool; // 池本体
    zc_stats_t stats;      // 全局统计

    // === 注册列表 ===

    // === 内部线程 ===

} zc_memory_pool_t;
```

- **分配方式**：初始化时池本体 lazy_alloc 直到有第一个写入者注册，运行时可以动态扩缩容。
- **对齐要求**：`base_addr` 与 `total_size` 均对齐至 512 B（缓存行与块大小公约数）。
- **生命周期**：`zc_init()` 创建，`zc_destroy()` 归还给 OS。

### 1.2 内存块布局

| 区域 | 大小 | 说明 |
|------|------|------|
| Header | 64 B | 含状态、ID、引用位图、时间戳 |
| UserData | 用户请求长度 | 返回给用户的指针即此区域首地址 |
| Trailer | 24 B | 守卫结构（canary + done + checksum） |
| Padding | 0 ~ 424 B | 使总和为 512 B 的倍数 |

- Header
```c
typedef struct zc_block_header {
    _Atomic uint16_t  state;           // FREE=0, USING=1, CLEAN=2, CORRUPT=3
    uint16_t          reserved_flags;  // 未来扩展位
    uint32_t          writer_id;       // 写入者ID
    uint64_t          data_size;       // 用户数据大小（单位：字节）
    zc_time_t         timestamp;       // 写入时间戳

    uint64_t          padding;

    // === 并行引用位图===
    _Atomic bool      writer_ref[ZC_MAX_WRITERS];         // 写入者实时引用
    _Atomic bool      reader_ref[ZC_MAX_READERS_PER];     // 读取者实时引用
    _Atomic bool      reader_visited[ZC_MAX_READERS_PER]; // 读取者访问历史
} zc_block_header_t;

// #define HEADER_SIZE 128
```

- Trailer
typedef volatile zc_block_trailer struct {
    uint64_t  canary;      // 守卫量：初始值为魔数，被篡改即触发报警
    uint64_t  done;        // 停车标志：非0=运行中，0=停止监测
    uint64_t  checksum;    // 可选CRC（默认0，启用时计算）
} zc_block_trailer_t;

> **可见性约定**：
> Header 与 Trailer 仅由内部读写，外部不触碰。

### 1.3 块状态机（单字节原子）

| 状态值 | 名称 | 含义 |
|--------|------|------|
| 0 | FREE | 空闲可分配或正在被争夺 |
| 1 | USING | 写入者已提交，读取者可消费 |
| 2 | CLEAN | 正在清理或合并 |
| 3 | CORRUPT | 守卫检测到越界写，等待回收 |

**合法转换**（只有以下 6 种）：

1. FREE → USING：写入者成功获取（写者优先，CAS 状态即可）。
2. FREE → CLEAN：清理者开始合并相邻 FREE 块。
3. USING → CLEAN：清理者确认 reader_visited 中（除了异常者或者自主退出者之外）所有需要读取的读取者对应位为 1 且所有引用位图为 0
4. USING → CORRUPT：守卫线程发现 canary 被篡改。
5. CLEAN → FREE：清理者完成合并，把长度累加到前驱块。
6. CORRUPT → CLEAN：清理者开始回收损坏块。

### 1.4 注册表
<TODO>

### 1.5 系统线程简述
<TODO>

---

## 二、写入者及其守卫

### 2.1 注册与 ID 规则

```c
ZC_API zc_result_t zc_writer_register(const zc_thread_config_t* conf,
                               zc_writer_id_t* out_id);
```

- ID 分配：静态数组索引 0~31，先到先得。
- 伴随动作：
  - 创建 `zc_writer_workspace_t`。
  - 创建守卫线程（见 2.5）。

### 2.2 写入者工作空间

```c
typedef struct zc_writer_workspace {
    // === 状态标识 ===
    _Atomic uint32_t     state;
    uint32_t             reserved;

    // === 心跳与缓存 ===
    _Atomic uint64_t     last_heartbeat;
    _Atomic uint64_t     last_jump_dest;
    uint64_t cached_offset;

    // === 线程注册信息 ===
    zc_writer_registry_t writer_info;

    // === 消息系统 ===
    zc_rwer_msg_space_t  msg_space;

    // === 性能统计 ===
    uint64_t             writed_count;
    uint64_t             message_count;
} zc_writer_workspace_t;

### 2.3 获取块（写者优先路径）

```c
ZC_API zc_result_t zc_writer_acquire_block(zc_writer_id_t writer_id,
                                    size_t size,
                                    zc_block_handle_t* out_handle,
                                    uint64_t timeout_ns);
```

内部逻辑：
- 按策略挑候选块（先 cached_offset 的后向邻接块 → 再 guide 地址 → 全局遍历）。
- 挑选逻辑：
  - 检查 `state == FREE && 无任意引用位被置 1`。
  - 检查块的可用大小不小于参数中要求的 size + 24 B。
  - 原子置 `writer_ref[idx] = true`。
  - CAS `state FREE→FREE` 防止与清理者的竞态。
  - 检查 `writer_ref 中比自己靠前的位全 false`。
  - 成功则确认获取当前块。
  - 更新信号量唤醒守卫（`zc_guard_on_attach()`）。
  - 更新 cached_offset 并将旧 cached_offset 指向的 header 中的 `writer_ref[idx] 原子置为 false`。
  - 判断当前块的可用大小减去自己要求的 size 之后剩余量是否大于 512 B，如果是则需要将剩余部分新增 header 标记可用块。
  - 填写时间戳（调用 `zc_timestamp()`）并返回 UserData 指针。
- 失败处理：
  - 立即放弃，寻找其他块。
- 超时机制：
  - 每次检查块后检查耗时，硬截止 `timeout_ns`，到点返回 `ZC_ERROR_TIMEOUT`。

> 保证：低 ID 优先 + 不主动抢占已持有块 + 无忙等。

### 2.4 提交与取消

```c
ZC_API zc_result_t zc_writer_commit_block(zc_writer_id_t writer_id);
```

- 填写时间戳（调用 `zc_timestamp()`）。
- 原子置 `state = USING`。
- 对内存块不再可写，通知守卫将 `user_handle` 更改为 `UAF 错误地址（通过宏或者全局共享变量定义）` 然后重新休眠。

```c
ZC_API zc_result_t zc_writer_cancel_block(zc_writer_id_t writer_id);
```

- 仅填写时间戳（调用 `zc_timestamp()`）并触发守卫清理逻辑（同上）。
- 忽略可能更改的 UserData。

### 2.5 块尾守卫（越界写监测）

- 初始化：`register` 时配套创建并阻塞在信号量上。
- 触发时机：`acquire` 时调用 `zc_guard_on_attach()` 唤醒守卫线程。
- 数据结构：

```c
typedef zc_guard_task struct {
    zc_block_tail_t*   tail;        // 监测目标
    _Atomic int32_t    state;       // 守卫状态
    zc_writer_id_t     writer_id;   // 所属写入者ID
    pthread_cond_t     go;          // 启动条件变量
    uint64_t           canary;      // 随机的守卫魔数变量
    void**             user_handle; // 用户handle指针缓存
    zc_memory_pool_t*  mp;          // 所属内存池
} zc_guard_task_t;
```

- 守卫线程唤醒初始化

```c
void zc_guard_on_attach()
{
    // 更新自己的 zc_guard_task_t，其中 canary 更新为一个新的随机数

    // 初始化块末守卫段

    zc_guard_on_detect();
}
```

- 守卫线程检测循环：

```c
void zc_guard_on_detect(zc_guard_task_t* t)
{
    /* 1. 局部变量初始化 */
    uint32_t exp  = 1; // 指数退避初始空转次数
    zc_block_tail_t* tail = t->tail;
    uint64_t right_magic = t->canary;

    while (likely(!tail->done))
    {
        /* 2. 热路径：单次 load + 比较 */
        uint64_t curr = tail->canary;
        if (unlikely(curr != right_magic))
        {
            /* 3. 异常处理 */
            zc_guard_stop_writer(t); // 阻断写入者
            zc_guard_report(t); // 报告
            break;
        }

        /* 4. 指数退避 + PAUSE */
        for (uint32_t i = 0; i < exp; ++i)
            cpu_relax();
        exp = MIN(exp * 2, 256);
    }
    return;
}

```

- 写入者阻断实现：  
  - `zc_guard_stop_writer()` 触发时将 `user_handle` 改为 `BOF 错误地址（通过宏或者全局共享变量定义）`，实现“纯软件立即阻断”。

- 异常报告处理（zc_guard_report()）：
  - 修改块 header 的 state 为 CORRUPT
  - 通过依附的写入者的消息通道向清理者报告完整的异常信息
  - 触发 Hook

---

## 三、读取者

### 3.1 注册与 ID 规则

```c
ZC_API zc_result_t zc_reader_register(zc_writer_t target_writer,
                               zc_reader_id_t* out_id);
```

- ID 高 32 位 = `writer_id`，低 32 位 = 自增序号 → 至多 32 读者/写入者。

```c
typedef struct zc_reader_workspace {
    // === 状态标识 ===
    _Atomic uint32_t state;
    uint32_t reserved;

    // === 心跳与缓存 ===
    _Atomic uint64_t last_heartbeat;
    _Atomic uint64_t last_jump_dest;
    uint64_t cached_offset;
    void** user_handle;

    // === 线程注册信息 ===
    zc_reader_registry_t reader_info;

    // === 消息系统 ===
    zc_rwer_msg_space_t msg_space;

    // === 性能统计 ===
    uint64_t read_count;
    uint64_t message_count;
} zc_reader_workspace_t;

#define READER_WS_SIZE ( )
```

### 3.3 查找未读块（尽力 FIFO）

```c
ZC_API zc_result_t zc_reader_poll_block(zc_reader_id_t reader_id,
                                 size_t hint_size,
                                 zc_block_handle_t* out,
                                 uint64_t timeout_ns);
```

内部逻辑：
- 从 `cached_offset` 开始向后线性扫描。
- 匹配条件：
  - `state == USING`
  - `writer_id` 与注册目标一致
  - `reader_visited[reader_idx] == false`
- 当读取到不匹配的块，访问对应写入者的 `LastJumpDest`，只检测对应块不向后线性扫描，仍不匹配从头遍历。
- 置 `reader_ref[idx] = true` 与 `reader_visited[idx] = true`。  
- 更新 `cached_offset`，释放对旧缓存块的 `reader_ref[idx]` 并返回 UserData 指针
- 允许检查超时，否则持续遍历。

### 3.4 释放引用

```c
ZC_API zc_result_t zc_reader_release_block(zc_block_handle_t* h);
```

- 取消访问权限，将 user_handle 修改为 `UAF 错误地址（通过宏或者全局共享变量定义）` 。

---

## 四、清理者及其内部协作

### 4.1 角色与生命周期

- 默认至少 1 个清理者，可动态增至 `cleaner_max_count`。
- 新增/退出负载率投票决定、由当值着执行。
- 每个清理者拥有独立 `zc_cleaner_context`，共享 `zc_cleaner_workspace`。

typedef struct zc_cleaner_workspace {
    // === 消息系统 ===
    zc_rwer_msg_space_t msg_space_for_writers[ZC_MAX_WRITERS];
    zc_rwer_msg_space_t msg_space_for_readers[ZC_MAX_WRITERS][ZC_MAX_READERS_PER];

    // === 指导地址 ===
    zc_free_block_guidance blk_guide[ZC_MAX_WRITERS];

    // === 性能统计 ===
    _Atomic uint64_t clean_count;
    _Atomic uint64_t message_count;
} zc_cleaner_workspace_t;

### 4.2 清理者工作逻辑

- 遍历：从池首开始，根据每个 header 按块遍历内存池。
- 清理：识别可清理块（USING 状态、所有需访问的读取者已访问、引用位图全零），将其状态更新为 CLEAN、清零读取者访问记录位图；然后继续遍历直到遇到不可清理的块，然后将中间经过的块的长度（包括header）累加更新到连续序列的第一个块 header 中。
- 合并：识别空闲块（FREE 状态、位图全零）并缓存其偏移量；继续遍历，如果遇到的是一个新的空闲块，则将其标识 CAS 为 CLEAN 并累加其 size（包括 header），直到遇到非空闲块或 CAS 失败；然后再次检查缓存的块（连续序列的第一个块）是否仍然空闲，如果空闲则将其 data_size 原子地加上累计的后续 size，如果不空闲则只修改其后块（连续序列的第二个块）的 data_size 为累计的后续 size - HEADER_SIZE。
- 未读通知：遍历到 USING 状态的块时检查其读取者访问记录位图是否与预期的“所有读取者均已访问”的状态一致，如果不一致则检查其时间戳与当前时间是否达到间隔阈值，如果达到则需检查未完成读取的读取者心跳并向其发送 ZC_MSG_MISSING_BLOCK 消息。
- 空闲块提示：根据 zc_alloc_strategy 中定义的逻辑，对于例如长度足够且与前置内存块的写入者一致、或者长度过长可以分割等的空闲块，将其偏移量提供给所有或特定的writer，推荐它们在无法保持内存块使用连续性时跳转使用。
- 统计与背压处理：遍历过程中累计相关信息，根据 zc_backpressure_strategy 中定义的逻辑计算出负载率，在负载率达到阈值时通知写入者和读取者、动态扩缩内存池等。

### 4.3 MessageRing 内部消息

- 环线结构：双向链表节点，每节点 = 一个清理者。  
- 消息类型（待完善）：

| 消息码 | 含义 |
|--------|------|
| MSG_MERGE_REQ | 请求邻居暂停并协助合并 |
| MSG_SCALE_UP | 投票增加清理者 |
| MSG_SCALE_DOWN | 投票减少清理者 |

- 传递方式：  
  - 常规：单向单包，指针沿环转发，命中 dst 即处理。  
  - 关键：双向双包，确保至少一个方向送达。  
- 当值者简介：首个发送的包带 `ownership_token=1`，收到者即为当值；超时未心跳则由守护者线程随机指定新当值者并广播。
- 接口：
  - 注册节点，包括元数据和一系列与消息类型对应的事件驱动的函数指针。
  - on_message()，内部自动完成所有消息检查、处理、转发和当值着身份传递逻辑，调用注册的函数指针处理对应类型的消息，更新心跳。
  - 注销节点。

### 4.4 运行时动态优化

- 动态扩缩容：扩容和缩容都以子内存段为单位，内存池在创建时即可划分子内存段（如配合 NUMA 优化），扩容时先准备好新的内存段，然后更新指针翻译器，最后锁定内存池末块（标记为 CLEAN）、更新内存池的元数据和末块的 header。
- 动态多清理者步进偏移：以相隔时间而非相隔偏移量为均衡指标，使得整体各个内存块的“最大清理者扫描时延”最小化。

---

## 五、整体补充内容

### 5.1 注册表与热更新

```c
typedef struct {
    zc_writer_registry_t   writers[ZC_MAX_WRITERS];
    zc_reader_registry_t   readers[ZC_MAX_WRITERS * ZC_MAX_READERS_PER];
    zc_cleaner_context_t   cleaners[ZC_MAX_CLEANERS];
    atomic_flag            lock; // 仅用于注册/注销临界区
} zc_registry_t;
```

- 读写分离：注册/注销需拿 `lock`；查询（遍历时）无锁，读端使用 `atomic_load(&count)` 快照。
- 故障清理：看门狗线程每 100 ms 检查心跳，超时即强制清 `writer_ref` / `reader_ref` 并更新其元数据中的状态信息。

### 5.2 主消息通道

- 主消息通道采用双缓冲设计，用于外部工作线程（写入者和读取者）与系统线程（清理者）之间的通信。
- 消息头格式：

```c
typedef struct zc_msg_header {
    uint16_t         version;      // 版本号
    uint8_t          type;         // zc_message_type_t
    uint8_t          length;       // payload 长度（字节）
    zc_short_time_t  create_time;  // 创建时间
} zc_msg_header_t;
```

  - 消息头后紧邻 payload，多个消息在缓冲区内连续追加，形成紧凑的消息流。

- 消息元数据窗口数据结构：

```c
typedef struct zc_rwer_msg_space {
    _Atomic uint16_t  read_version;     // 自己作为接收方，已读取的最新版本
    _Atomic uint16_t  write_version;    // 自己作为发送方，活动缓冲区的版本
    atomic_bool       buffer_swapping;  // 缓冲区切换中标志
    atomic_bool       is_accumulating;  // 是否有积累的消息
    atomic_uintptr_t  active_buffer;    // 当前活动缓冲区
    atomic_size_t     msg_count;        // 活动缓冲区中的消息数量
    atomic_uintptr_t  standby_buffer;   // 备用缓冲区
} zc_rwer_msg_space_t;

// #define RWER_MS_SIZE 32
```

  - 此结构体是外部线程工作空间的一部分；清理者工作空间包含zc_rwer_msg_space_t[]数组，与每个外部线程维护一一对应的独立窗口。
  - standby_buffer 不应该被接收方访问，其有效性和安全性在运行时不做任何保证，仅供发送方缓存使用。

- 消息发送接口：

```c
ZC_API zc_result_t zc_writer_send_message(
    zc_writer_id_t writer_id,
    zc_message_type_t type,
    uint16_t length,
    const void* msg
);

ZC_API zc_result_t zc_reader_send_message(
    zc_reader_id_t reader_id,
    zc_message_type_t type,
    uint16_t length,
    const void* msg
);

inline zc_internal_result_t zc_cleaner_send_message_to_writer(
    zc_writer_id_t writer_id,
    zc_message_type_t type,
    uint64_t content
);

inline zc_internal_result_t zc_cleaner_send_message_to_reader(
    zc_reader_id_t reader_id,
    zc_message_type_t type,
    uint64_t content
);
```

  - 将消息追加写入备用缓冲区。
  - 访问接收方的工作空间，检查其读取版本是否等于当前活动缓冲区版本。
  - 如果相等，将备用缓冲区切换为活动缓冲区，换下来的缓冲区可复用/释放。
  - 如果不相等，将is_accumulating置为true。
  - is_accumulating为true时，触发定期检查接收方读取版本的逻辑，一旦检测到接收方读取版本等于活动缓冲区版本，触发原子切换。
  - 对于清理者（系统线程），只由当值者调用。

- 消息接收接口
```c
ZC_API zc_result_t zc_writer_check_message(
    zc_writer_id_t writer_id,
    size_t* receive_number,
    size_t* unprocessed_number,
    void* unprocessed_msg_stream
);

ZC_API zc_result_t zc_reader_check_message(
    zc_reader_id_t reader_id,
    size_t* receive_number,
    size_t* unprocessed_number,
    void* unprocessed_msg_stream
);

inline zc_internal_result_t zc_cleaner_check_message(void);
```

  - 比较本地读取版本缓存与发送方的活动缓冲区的版本。
  - 如果不相等，读取新消息。
  - 根据消息类型查找是否有已注册的处理函数指针，（对于外部线程）如果没有则将消息内容复制并通过参数传回，或者（对于内部线程）使用注册的 `DEFAULT` 处理函数
  - 处理完成后原子更新本地读取版本缓存。

- 消息转发函数

```c
inline void zc_cleaner_transpond_message_to_writer(
    zc_writer_id_t writer_id,
    char* content,
    uint8_t length
);

inline void zc_cleaner_transpond_message_to_reader(
    zc_reader_id_t reader_id,
    char* content,
    uint8_t length
);
```

  - 当清理者检测到一个类型为 `REQ_TRANSPOND` 的消息时，调用这两个函数。
  - 转发消息的消息头中 `create_time` 继承原消息。

---

## 六、 测试用例

<TODO>

---

## 七、总结

1. 共享内存布局与无锁状态机；  
2. 写者优先的分配与守卫阻断机制；  
3. 读者尽力 FIFO 的遍历策略；  
4. 清理者基于 MessageRing 的协作与动态伸缩；  
5. 注册表、心跳、性能、跨平台、测试等配套要求。
