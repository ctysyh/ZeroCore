更新事项记录
本文档记录代码构建过程中的关键提示词。

### 更新事项v1.1
1. 缺少了注册列表。注册列表中应该包含所有写入者和读取者的识别名称（供调试输出）、线程ID、写入/读取的数据块身份tokens、预期写入/读取数据大小和速度等（还需要有哪些？），其中各个读取者注册的读取数据块身份tokens是清理者在检查一个内存块是否被所有需要的读取者全部读取的依据，预期写入/读取数据大小和速度是计算内存池长度和写入者写入偏移量阈值的关键依据。这个注册列表应该支持运行时更改，包括确认某个线程故障或其自主申请的退出、和新线程的加入，修改和重载会影响到正在工作的写入者和读取者吗？清理者应该如何正确地接收修改后的新表呢？。这个注册列表也应该包含清理者的信息，不过清理者我们认为是系统内部的线程，它不会执行对数据的处理工作，而是作为系统的维护者，其并行数量和并行步进偏移由系统内决定。除了这些内容，注册列表还有哪些需要的？（注：我发现在现在的代码中，这里一部分的信息其实记录在zc_config_t中，我们需要重新分析梳理这里的逻辑关系和最优设计）
2. 消息结构和我们前述的逻辑不完全契合。我进一步完善：这里的消息在逻辑上是外部的写入者和读取者同系统进行交互的，在设计上由清理者（或者在高负载时也可以引入专门的内部通讯线程）负责；但是不论内部有多少个相关线程，对外部工作线程展现的都是其共同体，内部的协调逻辑放在内部考虑（这个逻辑也已经设计好，但不是现在的重点）；一个外部线程只可与清理者共同体通讯，其具体通讯方式是外部线程要发送消息时在自己的工作空间更新其自有的消息列表头指针（应当是原子的）和最新版本号/时间戳（用于让清理者知道有新消息），具体消息内容写在消息列表里（甚至不难支持要求清理者转发给其他外部线程的功能），清理者通过定期检查的方式比对缓存的上次处理时的版本号识别出有新消息然后通过指针访问到新消息列表进行处理；清理者发给外部线程的消息同理；但是这里需要处理一个边界情况即处理消息的一方正在处理中，而发送消息的一方突然新增了消息更新了消息列表（如何处理？COR是否会造成过多的性能开销？有没有什么好办法？）；另外还需要有一个机制让处理消息的一方告知发送消息的一方，某个版本号下的所有消息都已经处理完毕可以释放（这个机制能否通过一个具有特殊版本号和类别的消息来实现、这条消息由检测到原发送方将对应的普通消息释放后主动释放、无需循环反馈？我感觉上可能可以，但是会不会导致一些复杂情况或意外后果？）；消息列表内存的具体分配和释放由其持有线程自主完成，无需复杂逻辑（足够吗？）。在这些逻辑明确之后，我们可以重新设计消息相关的数据结构，包括作为工作空间一部分的固定格式的消息列表元数据、和具体的可变长度消息，我希望避免第二次寻址，直接将若干条消息排列在元数据中的指针指向的连续内存中，通过每条消息的消息头（包括消息版本号、消息类型、消息长度，还需要什么吗）来使得接收方可以正确读取所有消息。这样的设计是否良好？
3. 清理策略接口、分配策略接口和背压策略接口实际上都是作用到清理者的，而正如前述清理者我们认为是系统内部的成员，这三个接口应该属于系统接口，用于指定整个系统的运作行为。因此，这三个接口的设计需要调整。类似地，清理者接口部分的zc_cleaner_start、zc_cleaner_stop、zc_cleaner_set_strategy不应该暴露为接口。
4. 系统应该提供一个zc_timer来统一提供时间戳，虽然时间戳主要用于内部功能（心跳、块时间戳）由私有函数内部调用，但是考虑到读取者可能需要在外部比对、或者外部线程需要确认时间差等，应该提供一个接口获取时间戳（无参数，直接返回标量）
5. 部分接口应该将返回值改为bool，在参数中传递output指针
6. 考虑安全性和未来面向其他语言的进一步包装，尤其是适应实际写入者/读取者大概率会用面向对象的语言来编写其代码，这里的接口设计是否合适？在访问数据块时有没有可能提供一个安全机制防止无意/恶意的长度溢出（或许可以写在其他语言的包装里）？

### 更新事项v1.2
1. 修改写入者和读取者的ID和身份声明逻辑，一个写入者只应该写入同一种数据，一个读取者也只应该读取同一种数据，外部线程/应用可以通过注册多个读取者/写入者来读取/写入多种数据。读取者是依附于写入者的，一个写入者最多可以附带32个读取者，读取者ID的前32位是其所依附的写入者的ID，写入者ID是32位、读取者ID是64位。每个读取者的读取情况即记录在内存块header中（即前述逻辑）。举个例子，一个外部应用是实时字幕生成，它同时注册一个读取者audio_listen_by_subtitle_recog以读取websocket_audio_receiver（一个写入者）的数据和一个写入者realtime_subtitle_recog以写入字幕数据，websocket_audio_receiver的ID（转为十进制）是1，audio_listen_by_subtitle_recog的ID（转为十进制）是4294967297，realtime_subtitle_recog的ID（转为十进制）是4；又有一个外部应用是视频字幕压制，它同时注册三个读取者audio_listen_by_suppression（读取websocket_audio_receiver）, video_listen_by_suppression（读取http_vedio_stream，这个写入者ID转为十进制是2）, subtitle_listen_by_suppression（读取realtime_subtitle_recog），它们的ID（转为十进制）依次为4294967298、8589934593、17179869185。这个例子很好地说明了我们设计的注册接口会如何被使用、序号如何分配。
2. 消息使用双缓冲。发送方在将一组消息写入缓冲区并暴露缓冲区handle之后，有新消息需要写入时，检查接收方的最新读取版本是否已经将缓冲区中的消息全部覆盖；如果没有，则把新消息写在一个新的缓冲区；直到（要追加某个消息时或者是有累积消息的情况下定期）检测到接收方已经处理完成暴露的缓冲区内的所有消息时，原子地把缓冲区中暴露的handle改为新的缓冲区，然后旧的缓冲区可以回收或复用。版本号即当前暴露在工作空间中的handle的更新次数，初始化为0，第一次写入消息版本号为1，接着每更新一次缓冲区handle版本号+1，在内部缓冲区积累期间所有积累消息的版本号均为暴露缓冲区的版本号+1。这样，接收方在缓冲区中看到的所有消息都具有相同的版本号，而消息在缓冲区内排列的顺序自然地表示它们生成的先后次序。消息模块的接口简化为 writer_send, writer_check, reader_send, reader_check，这些处理逻辑封装在函数内部。
3. 调整一些内容的外部可见性。外部可见的内容应该以接口为核心，并暴露接口的参数/返回值所需的数据结构。当前zerocore.h（v1.1）中有部分内容应该放置在zerocore_inner.h中。
4. 调整zerocore.h中的各段代码的顺序和分类，使得其更符合之后面向对象、面向接口的包装需求。

### 更新事项v1.3.1
1. 细化清理者的设计。首先根据详细叙述的逻辑重新设计其功能逻辑配置接口，然后深入多清理者并行优化。应该由逻辑配置接口提供一个函数，检测新增/关闭清理者的条件并触发新增或关闭的操作；在多清理者并行控制方面，考虑引入一个我之前另外设计的MessageRing，这是一个无锁的、采用“当值者”机制实现共享资源无冲突管理、将所有节点编排成双向链表、同样采用独立工作空间设计实现绝对无锁且极少原子变量的高性能消息传递管线，然后设计一套内部消息体系，用于清理者间（甚至未来为重型应用引入的专职外部消息处理者等其他系统线程）的信息交流协作。
2. 考虑内存块header中的原子和同步设计优化。现在使用位图和原子操作用于跟踪写入者和读取者实时引用量和读取者访问记录。但是显然它们写入的时候是不需要关心其他位的，只需要把自己对应的位修改成一个值，只有写入前或其他时刻的检查才需要读取其他位的值。现在在并发写入的时候实际上仍然是非并行的（原子操作），但是理论上来讲写入是确实可以并行的。有没有可能通过一些特殊的数据结构或者编译优化（甚至包括内联汇编），提高这里的效率？
3. 我其实一直有一个隐藏的原则，即写者优先，现在明确为设计原则之一。我认为写者的即刻获取内存块是必要的，如果能够保证这一点，就可以让写者少用一道缓冲区，直接在实时流马上到达的时候获取一个适当冗余的内存块然后把流写入，这对于整体性能的提高是非常有益的；考虑未来的其他语言包装，包括异步、future、promise等功能的底层满足，写者意外过长的等待内存块的过程甚至可能导致其逻辑错误。而读者稍微等待并不会带来错误的风险，至多导致略微的延迟。
4. 探索生产模式下低开销的短校验和与放置在每个数据块末端的守卫信号量，用于外部线程申请的篡改检查和实时溢出报警。

### 更新事项v1.3.2
1. 让我补充更多关于MessageRing的信息。正如前面所说的，MessageRing将所有节点排成双向链表的结构。在这个结构中，每个节点有左右两个缓冲区，分别由左右两个相邻节点写入、自己读取。当一个节点发送一个消息包，它有两种方式，一种是单向单包，即选择间隔更近的方向发送一个消息包，在包头写明目的节点（允许有多个），然后在缓冲区检查到消息包的节点需要检查包头信息是否需要处理，然后保持方向继续发送给下一个节点，直到包回到发送者手中/达到DDL/可信情况下需要接收的节点接收到处理之后即将包释放，中间传递时传递指针；另一种是双向双包，即向左右两个方向各发送一个消息包，适用于重要的、不可丢失的消息，传递逻辑同上。MessageRing的“当值者机制”是通过一个机制在任意一个时刻唯一确定一个当值者，负责管理公共数据、代表本环线与外部通信，在通用实现中当值者的选定是跟随一个消息包，消息包传递到谁谁就是当值者，这个消息包的选定通常是环线中的第一个消息包，在这个包可以释放时当值者身份保留在最后一个持有这个包的节点，直到它也发送一个消息包、当值者身份即跟随这个新包传递，或者它心跳超时、由守护者线程随机指定。MessageRing还可以嵌套，大MessageRing的每个节点都是小MessageRing，然后各个节点之间的通信由各自的当值者负责。
在我们这里的应用中，让具有当值者身份的清理者负责管理清理者共享工作空间，是一个非常直接的选择。然后我们可以设计一套内部消息枚举，用于运行时内存块动态管理的协同、一些关于全池的调整投票等。
2. 安全机制中，能否通过某种（近似）信号量的机制，实现buffer overflow的立即报警；CRC校验和可由外部线程可选触发，让那些需要更多安全保证而愿意放弃最极致性能的应用和数据指定开启，否则使用另一个固定魔数避免计算开销；配套地，在写入操作中，是否能够提供一个机制实现立即强制阻断写入，如果块尾守卫能够实现成信号量的话就可以在写入函数的内部实现中监听在这个信号量上，提示硬件执行阻断。
3. 我认为内存块header结构可以不用强制对齐512字节，而是应该尽可能短（但是仍应该对齐64字节的倍数），因为同一个块之内是不会发生缓存污染的，对于写入者而言，它们在检查、获取一个块时这个块的userdata部分是不会改变的；对读取者而言，它们在检查一个块时如果有写入者正在写入userdata，它们是不会等待的而是立即检查下一个块，缓存污染的概率和影响不大、且读取者不会写入因此也不会造成缓存乒乓。然后在块尾部也增加一段保留字节之后，header和trailer加上中间的userdata整体对齐512字节的行大小进行分行。
在此基础上，重新检查、继续优化header的设计。

### 更新事项v1.3.3
本更新聚焦于安全机制。在块尾守卫的设计中，我们采用一个新办法，略微增加开销，但是实现越界写的低延迟纯软件监测。以下通过伪代码形式给出思路，请你具体完善。
1. 块末守卫段数据结构
```c
typedef volatile struct {
    uint64_t canary;   // 8 B 守卫量
    uint64_t done;     // 8 B 停车标志
} zc_block_tail_t;
```
2. 守卫线程工作循环伪代码
```c
static void zc_guard_on_detect(void* arg)
{
    zc_block_tail_t* b = (zc_block_tail_t *)arg;
    /* 1. 快照 */
    uint64_t prev = b->canary;
    uint32_t exp  = 1; // 指数退避初始空转次数

    while (likely(b->done == 0))
    {
        /* 2. 热路径：单次 load + 比较 */
        uint64_t curr = b->canary;
        if (unlikely(curr != prev))
        {
            zc_guard_stop_writer(); // 阻断写入者
            zc_guard_report(); // 报告
            break;
        }

        /* 3. 指数退避 + PAUSE */
        for (uint32_t i = 0; i < exp; ++i)
            cpu_relax();
        exp = MIN(exp * 2, 256);
    }
    return;
}
```
这里zc_guard_stop_writer()和zc_guard_report()需要设计合适的实现。
具体来说，zc_guard_stop_writer()考虑通过在外部线程调用zc_writer_acquire_block时，缓存其handle参数（这是一个指针，我们预期外部线程会直接使用这个指针），需要停止时将这个指针修改为告警地址或者NULL；外部线程可能作弊时，应该由发行者/操作者关闭C接口，只提供高级语言接口并在其中增加隔离。这个方案可行吗？它能起到阻断外部线程对内存块的写入吗？zc_guard_report()在zc_guard_stop_writer的逻辑是确实取消写入者线程对内存块的使用权的情况下，直接修改内存块内容，通过一些标记让清理者遍历到这块内存时知道这里发生了写溢出异常。
3. 守卫线程的创建和绑定
守卫线程随写入者的注册而创建，阻塞在条件变量上。
```c
typedef struct {
    zc_block_tail_t* block;
    atomic_bool ready;
    pthread_cond_t go;
} zc_guard_task_t;

static inline void zc_guard_on_attach(zc_guard_task_t* t, zc_block_tail_t* b)
{
    t->block = b;
    t->ready = true;
    pthread_cond_signal(&t->go);     // 唤醒预创建线程
}
```