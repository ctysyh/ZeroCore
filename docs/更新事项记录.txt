更新事项记录
本文档记录代码构建过程中的关键提示词。

### 更新事项v1.1
1. 缺少了注册列表。注册列表中应该包含所有写入者和读取者的识别名称（供调试输出）、线程ID、写入/读取的数据块身份tokens、预期写入/读取数据大小和速度等（还需要有哪些？），其中各个读取者注册的读取数据块身份tokens是清理者在检查一个内存块是否被所有需要的读取者全部读取的依据，预期写入/读取数据大小和速度是计算内存池长度和写入者写入偏移量阈值的关键依据。这个注册列表应该支持运行时更改，包括确认某个线程故障或其自主申请的退出、和新线程的加入，修改和重载会影响到正在工作的写入者和读取者吗？清理者应该如何正确地接收修改后的新表呢？。这个注册列表也应该包含清理者的信息，不过清理者我们认为是系统内部的线程，它不会执行对数据的处理工作，而是作为系统的维护者，其并行数量和并行步进偏移由系统内决定。除了这些内容，注册列表还有哪些需要的？（注：我发现在现在的代码中，这里一部分的信息其实记录在zc_config_t中，我们需要重新分析梳理这里的逻辑关系和最优设计）
2. 消息结构和我们前述的逻辑不完全契合。我进一步完善：这里的消息在逻辑上是外部的写入者和读取者同系统进行交互的，在设计上由清理者（或者在高负载时也可以引入专门的内部通讯线程）负责；但是不论内部有多少个相关线程，对外部工作线程展现的都是其共同体，内部的协调逻辑放在内部考虑（这个逻辑也已经设计好，但不是现在的重点）；一个外部线程只可与清理者共同体通讯，其具体通讯方式是外部线程要发送消息时在自己的工作空间更新其自有的消息列表头指针（应当是原子的）和最新版本号/时间戳（用于让清理者知道有新消息），具体消息内容写在消息列表里（甚至不难支持要求清理者转发给其他外部线程的功能），清理者通过定期检查的方式比对缓存的上次处理时的版本号识别出有新消息然后通过指针访问到新消息列表进行处理；清理者发给外部线程的消息同理；但是这里需要处理一个边界情况即处理消息的一方正在处理中，而发送消息的一方突然新增了消息更新了消息列表（如何处理？COR是否会造成过多的性能开销？有没有什么好办法？）；另外还需要有一个机制让处理消息的一方告知发送消息的一方，某个版本号下的所有消息都已经处理完毕可以释放（这个机制能否通过一个具有特殊版本号和类别的消息来实现、这条消息由检测到原发送方将对应的普通消息释放后主动释放、无需循环反馈？我感觉上可能可以，但是会不会导致一些复杂情况或意外后果？）；消息列表内存的具体分配和释放由其持有线程自主完成，无需复杂逻辑（足够吗？）。在这些逻辑明确之后，我们可以重新设计消息相关的数据结构，包括作为工作空间一部分的固定格式的消息列表元数据、和具体的可变长度消息，我希望避免第二次寻址，直接将若干条消息排列在元数据中的指针指向的连续内存中，通过每条消息的消息头（包括消息版本号、消息类型、消息长度，还需要什么吗）来使得接收方可以正确读取所有消息。这样的设计是否良好？
3. 清理策略接口、分配策略接口和背压策略接口实际上都是作用到清理者的，而正如前述清理者我们认为是系统内部的成员，这三个接口应该属于系统接口，用于指定整个系统的运作行为。因此，这三个接口的设计需要调整。类似地，清理者接口部分的zc_cleaner_start、zc_cleaner_stop、zc_cleaner_set_strategy不应该暴露为接口。
4. 系统应该提供一个zc_timer来统一提供时间戳，虽然时间戳主要用于内部功能（心跳、块时间戳）由私有函数内部调用，但是考虑到读取者可能需要在外部比对、或者外部线程需要确认时间差等，应该提供一个接口获取时间戳（无参数，直接返回标量）
5. 部分接口应该将返回值改为bool，在参数中传递output指针
6. 考虑安全性和未来面向其他语言的进一步包装，尤其是适应实际写入者/读取者大概率会用面向对象的语言来编写其代码，这里的接口设计是否合适？在访问数据块时有没有可能提供一个安全机制防止无意/恶意的长度溢出（或许可以写在其他语言的包装里）？

### 更新事项v1.2
1. 修改写入者和读取者的ID和身份声明逻辑，一个写入者只应该写入同一种数据，一个读取者也只应该读取同一种数据，外部线程/应用可以通过注册多个读取者/写入者来读取/写入多种数据。读取者是依附于写入者的，一个写入者最多可以附带32个读取者，读取者ID的前32位是其所依附的写入者的ID，写入者ID是32位、读取者ID是64位。每个读取者的读取情况即记录在内存块header中（即前述逻辑）。举个例子，一个外部应用是实时字幕生成，它同时注册一个读取者audio_listen_by_subtitle_recog以读取websocket_audio_receiver（一个写入者）的数据和一个写入者realtime_subtitle_recog以写入字幕数据，websocket_audio_receiver的ID（转为十进制）是1，audio_listen_by_subtitle_recog的ID（转为十进制）是4294967297，realtime_subtitle_recog的ID（转为十进制）是4；又有一个外部应用是视频字幕压制，它同时注册三个读取者audio_listen_by_suppression（读取websocket_audio_receiver）, video_listen_by_suppression（读取http_vedio_stream，这个写入者ID转为十进制是2）, subtitle_listen_by_suppression（读取realtime_subtitle_recog），它们的ID（转为十进制）依次为4294967298、8589934593、17179869185。这个例子很好地说明了我们设计的注册接口会如何被使用、序号如何分配。
2. 消息使用双缓冲。发送方在将一组消息写入缓冲区并暴露缓冲区handle之后，有新消息需要写入时，检查接收方的最新读取版本是否已经将缓冲区中的消息全部覆盖；如果没有，则把新消息写在一个新的缓冲区；直到（要追加某个消息时或者是有累积消息的情况下定期）检测到接收方已经处理完成暴露的缓冲区内的所有消息时，原子地把缓冲区中暴露的handle改为新的缓冲区，然后旧的缓冲区可以回收或复用。版本号即当前暴露在工作空间中的handle的更新次数，初始化为0，第一次写入消息版本号为1，接着每更新一次缓冲区handle版本号+1，在内部缓冲区积累期间所有积累消息的版本号均为暴露缓冲区的版本号+1。这样，接收方在缓冲区中看到的所有消息都具有相同的版本号，而消息在缓冲区内排列的顺序自然地表示它们生成的先后次序。消息模块的接口简化为 writer_send, writer_check, reader_send, reader_check，这些处理逻辑封装在函数内部。
3. 调整一些内容的外部可见性。外部可见的内容应该以接口为核心，并暴露接口的参数/返回值所需的数据结构。当前zerocore.h（v1.1）中有部分内容应该放置在zerocore_inner.h中。
4. 调整zerocore.h中的各段代码的顺序和分类，使得其更符合之后面向对象、面向接口的包装需求。

### 更新事项v1.3.1
1. 细化清理者的设计。首先根据详细叙述的逻辑重新设计其功能逻辑配置接口，然后深入多清理者并行优化。应该由逻辑配置接口提供一个函数，检测新增/关闭清理者的条件并触发新增或关闭的操作；在多清理者并行控制方面，考虑引入一个我之前另外设计的MessageRing，这是一个无锁的、采用“当值者”机制实现共享资源无冲突管理、将所有节点编排成双向链表、同样采用独立工作空间设计实现绝对无锁且极少原子变量的高性能消息传递管线，然后设计一套内部消息体系，用于清理者间（甚至未来为重型应用引入的专职外部消息处理者等其他系统线程）的信息交流协作。
2. 考虑内存块header中的原子和同步设计优化。现在使用位图和原子操作用于跟踪写入者和读取者实时引用量和读取者访问记录。但是显然它们写入的时候是不需要关心其他位的，只需要把自己对应的位修改成一个值，只有写入前或其他时刻的检查才需要读取其他位的值。现在在并发写入的时候实际上仍然是非并行的（原子操作），但是理论上来讲写入是确实可以并行的。有没有可能通过一些特殊的数据结构或者编译优化（甚至包括内联汇编），提高这里的效率？
3. 我其实一直有一个隐藏的原则，即写者优先，现在明确为设计原则之一。我认为写者的即刻获取内存块是必要的，如果能够保证这一点，就可以让写者少用一道缓冲区，直接在实时流马上到达的时候获取一个适当冗余的内存块然后把流写入，这对于整体性能的提高是非常有益的；考虑未来的其他语言包装，包括异步、future、promise等功能的底层满足，写者意外过长的等待内存块的过程甚至可能导致其逻辑错误。而读者稍微等待并不会带来错误的风险，至多导致略微的延迟。
4. 探索生产模式下低开销的短校验和与放置在每个数据块末端的守卫信号量，用于外部线程申请的篡改检查和实时溢出报警。

### 更新事项v1.3.2
1. 让我补充更多关于MessageRing的信息。正如前面所说的，MessageRing将所有节点排成双向链表的结构。在这个结构中，每个节点有左右两个缓冲区，分别由左右两个相邻节点写入、自己读取。当一个节点发送一个消息包，它有两种方式，一种是单向单包，即选择间隔更近的方向发送一个消息包，在包头写明目的节点（允许有多个），然后在缓冲区检查到消息包的节点需要检查包头信息是否需要处理，然后保持方向继续发送给下一个节点，直到包回到发送者手中/达到DDL/可信情况下需要接收的节点接收到处理之后即将包释放，中间传递时传递指针；另一种是双向双包，即向左右两个方向各发送一个消息包，适用于重要的、不可丢失的消息，传递逻辑同上。MessageRing的“当值者机制”是通过一个机制在任意一个时刻唯一确定一个当值者，负责管理公共数据、代表本环线与外部通信，在通用实现中当值者的选定是跟随一个消息包，消息包传递到谁谁就是当值者，这个消息包的选定通常是环线中的第一个消息包，在这个包可以释放时当值者身份保留在最后一个持有这个包的节点，直到它也发送一个消息包、当值者身份即跟随这个新包传递，或者它心跳超时、由守护者线程随机指定。MessageRing还可以嵌套，大MessageRing的每个节点都是小MessageRing，然后各个节点之间的通信由各自的当值者负责。
在我们这里的应用中，让具有当值者身份的清理者负责管理清理者共享工作空间，是一个非常直接的选择。然后我们可以设计一套内部消息枚举，用于运行时内存块动态管理的协同、一些关于全池的调整投票等。
2. 安全机制中，能否通过某种（近似）信号量的机制，实现buffer overflow的立即报警；CRC校验和可由外部线程可选触发，让那些需要更多安全保证而愿意放弃最极致性能的应用和数据指定开启，否则使用另一个固定魔数避免计算开销；配套地，在写入操作中，是否能够提供一个机制实现立即强制阻断写入，如果块尾守卫能够实现成信号量的话就可以在写入函数的内部实现中监听在这个信号量上，提示硬件执行阻断。
3. 我认为内存块header结构可以不用强制对齐512字节，而是应该尽可能短（但是仍应该对齐64字节的倍数），因为同一个块之内是不会发生缓存污染的，对于写入者而言，它们在检查、获取一个块时这个块的userdata部分是不会改变的；对读取者而言，它们在检查一个块时如果有写入者正在写入userdata，它们是不会等待的而是立即检查下一个块，缓存污染的概率和影响不大、且读取者不会写入因此也不会造成缓存乒乓。然后在块尾部也增加一段保留字节之后，header和trailer加上中间的userdata整体对齐512字节的行大小进行分行。
在此基础上，重新检查、继续优化header的设计。

### 更新事项v1.3.3
本更新聚焦于安全机制。在块尾守卫的设计中，我们采用一个新办法，略微增加开销，但是实现越界写的低延迟纯软件监测。以下通过伪代码形式给出思路，请你具体完善。
1. 块末守卫段数据结构
```c
typedef volatile struct {
    uint64_t canary;   // 8 B 守卫量
    uint64_t done;     // 8 B 停车标志
} zc_block_tail_t;
```
2. 守卫线程工作循环伪代码
```c
static void zc_guard_on_detect(void* arg)
{
    zc_block_tail_t* b = (zc_block_tail_t *)arg;
    /* 1. 快照 */
    uint64_t prev = b->canary;
    uint32_t exp  = 1; // 指数退避初始空转次数

    while (likely(b->done == 0))
    {
        /* 2. 热路径：单次 load + 比较 */
        uint64_t curr = b->canary;
        if (unlikely(curr != prev))
        {
            zc_guard_stop_writer(); // 阻断写入者
            zc_guard_report(); // 报告
            break;
        }

        /* 3. 指数退避 + PAUSE */
        for (uint32_t i = 0; i < exp; ++i)
            cpu_relax();
        exp = MIN(exp * 2, 256);
    }
    return;
}
```
这里zc_guard_stop_writer()和zc_guard_report()需要设计合适的实现。
具体来说，zc_guard_stop_writer()考虑通过在外部线程调用zc_writer_acquire_block时，缓存其handle参数（这是一个指针，我们预期外部线程会直接使用这个指针），需要停止时将这个指针修改为告警地址或者NULL；外部线程可能作弊时，应该由发行者/操作者关闭C接口，只提供高级语言接口并在其中增加隔离。这个方案可行吗？它能起到阻断外部线程对内存块的写入吗？zc_guard_report()在zc_guard_stop_writer的逻辑是确实取消写入者线程对内存块的使用权的情况下，直接修改内存块内容，通过一些标记让清理者遍历到这块内存时知道这里发生了写溢出异常。
3. 守卫线程的创建和绑定
守卫线程随写入者的注册而创建，阻塞在条件变量上。
```c
typedef struct {
    zc_block_tail_t* block;
    atomic_bool ready;
    pthread_cond_t go;
} zc_guard_task_t;

static inline void zc_guard_on_attach(zc_guard_task_t* t, zc_block_tail_t* b)
{
    t->block = b;
    t->ready = true;
    pthread_cond_signal(&t->go);     // 唤醒预创建线程
}
```

### 更新事项v1.3.4
本更新是一次设计探索，提出、验证“地址翻译器”结构。
地址翻译器结构在现有设计中虽然没有明确列出，但是在内存池的地址计算时其实已经隐含这个结构，也就是块地址 = 池首地址 + 偏移量。
我想到将这个结构细化设计、独立为一个模块，是因为在考虑内存池的动态扩缩容功能时，考虑以内存段为单位，尤其是在后续zc_platform中加入NUMA的支持、在每个注册者较为邻近的物理内存区块请求分配内存段，提高P50性能，动态扩缩容就是加载和卸载内存段，甚至还可以支持运行时数据转移等功能。又想到现在对于外部线程的写入阻拦和读取阻拦（UAF阻断）都是通过篡改其指针指向，达到保护内存池数据的效果，这一点非常容易被外部线程缓存指针绕过。
从而我在考虑，是否有可能做到一个地址翻译器，在访问内存池本体和其他系统资源时通过一个统一的偏移量请求，然后调用翻译器获取真正的地址。
这一点看起来并不困难，尤其是系统的内部使用，只需要一个参数为偏移量、返回值为地址的函数，函数内部通过简单的加减运算和少量的元数据即可实现。但是考虑面向外部的阻断，似乎不容易通过这样一个运行在应用态的引擎实现。

### 更新事项 v1.4.1
本更新聚焦于地址翻译器的初步落地。其核心是以身份凭证取代裸指针，以函数调用取代直接内存访问，在不依赖编译器改造和外部代码质量的前提下，实现对共享内存池的绝对安全管控与高效访问。
引入 `zc_handle_t` 作为统一访问凭证。该凭证由系统在块分配时动态生成，采用随机化或轻量级加密算法构造，既保证与内部块记录的快速映射，又具备基础防伪造能力。所有内存读写操作均需通过凭证调用API（如 `zc_read_u64`, `zc_write_bulk`）完成。API内部执行鉴权与地址翻译。
本次更新本质是将ZeroCore的内部运行与核查逻辑构建为一套运行时符号表，如同C编译器将变量名映射为地址，ZeroCore将 `(handle, offset)` 受验证地映射为地址，提供纯净、安全、高性能的数据搬移原语。本次更新的API在外部代码看来，将会像是特殊的堆内存。
ZeroCore未来在接口适配和性能优化上的工作，与编译器对于内存操作和运算的优化非常类似。这里的接口调用成为两侧代码（外部应用侧和ZeroCore侧）编译优化的“中间断点”，v2将着重解决这个问题，实现在ZeroCore内部预编译执行硬件级二元操作、减少数据进出寄存器次数的构想。

### 更新事项 v1.4.2
本更新聚焦于地址翻译器中的块内用户数据类型标识。在v1.4.1中提出了一个运行时标记的类型信息记录方案，现在进一步细化。首先我们需要一套编码来表达每种数据类型，我们使用微软 CLI 规范（ECMA-335），而且后续的需要规范性的内容都优先依照微软规范执行。在这套规范中，提供了空值、原始标量、托管引用级、结构体、指针、类型变量或修饰6大类数据类型，并留了高2bit作标志位。这些数据类型的行为同样遵循微软规范，不过在当前版本不涉及。其次，我们需要确定一套逻辑来保存这些元数据，我希望元数据跟着数据跑，也就是直接在内存块中、实际数据的附近保存元数据，但是具体在哪里保存呢？假如接续在块头，那块所占据的行数（ZC的一行是512字节）是可变的、一行里面不同宽度的数据的最大数量也不一样，如何能够留出恰当的空间呢？假如直接跟在实际数据前方或者后方，那又如何能够区分元数据和实际数据呢？或者还能放在哪呢？因为我们的API是申请一块确定大小的内存，但是中间可以任意使用，直到调用API将内存块提交，因此我们应该预期块内的数据是动态增减的。请你着重分析、考虑这里的设计。
接着在确定了这个规范之后，我们的API可以简化，尤其是这一批简单的load和store，直接使用非类型、仅宽度的内部逻辑，然后让外部通过参数（枚举类型）传入数据类型。
让我追加一些更改：我在微软规范的基础上，详细设计了一套类型描述符规则，参见后附。DTTA中直接使用这些类型标识符即可。
然后考虑API行为。写入者通过API store了一个新变量，写入者需要明确新变量在块中的偏移量，在这一层不提供从字符串变量名到偏移量的映射，后续可以考虑在其他语言的包装层加入这个映射（这是后话），不过类型标识符也提供了块内指针，有助于缓解这个问题。当写入者store了一个变量时，估计其前方可能会在未来新增多少其他变量，从而选择一个预留量、在DTTA的特定位置中写入元数据，这个估计算法应作为函数指针，方便后续更新。当写入者store了一个变量与一个现有的变量冲突时、且至少一个是有类型的，写入无法成功、返回错误码，如果两者都是无类型的，允许写入、返回警告、在DTTA中修改作为其附加token的宽度数据。当写入者delete了一个变量，严格要求其传入的偏移量是一个已有变量的起始偏移量，删除整个变量，除非是无类型变量则释放从偏移量开始到变量末结束的空间、修改DTTA中的对应附加token。写入者还需要哪些写入相关的API？
读取者通过API load了一个变量时，执行类型检查，在参数中传入期待变量的完整类型描述符，内部将期待值与实际值检验是否匹配，至于读取者提供的接收buffer由其自己的代码保证合法性。同一类型的有无符号扩展版本亦不允许匹配，读取者自己的代码中做后续处理。读取者还需要哪些读取相关的API？另外，写入者也有权限调用load系列API。
然后考虑一些常用的比较、遍历、排序、sizeof等，在当前阶段可以立即实现的有哪些？
请你广泛地考虑、仔细地设计，给出当前阶段应该实现的API列表及其预期行为，作为需求文档的重要部分。

附：（ZeroCore Zora 需求文档-v0：章节1.1 类型描述符，略）

### 更新事项 v1.4.3
本次更新着重完善定名为Zora的安全访问器的内部设计。
首先是zc_handle_t的具体算法。我希望从zc_handle算出实际内存地址的中间过程尽可能简短，但是保证安全性。我想到使用一个随机密钥，然后利用这个密钥加密实际内存地址，访问时只需解密。然后64位的地址我们预留56位，保证长期的兼容性；剩下8位可能可以是一个版本号？这个版本号是归属于对应的外部线程的，用来识别是否过期；整体加密，确保地址和版本号都不会泄露。
密钥的生成我考虑由清理者（系统线程）完成，比如由清理者定期向每个外部线程通过消息管线发送消息，这个消息管线在工作空间内部是安全的，新的密钥放在消息里，让外部线程在调用提交或取消API时API内部更新密钥。
然后考虑如何处理外部线程的工作空间。这个工作空间的实际地址基本是静态的，但是里面的内容属于系统的内部内容而且不适合加密。这个地址应该是与外部线程的ID对应的。
在这样的设计下，这个安全访问器就依赖于对应每个外部线程的缓存空间，包括版本号、密钥和工作空间地址。但是这些信息是对应于每个外部线程的，这意味着外部线程可能需要同时提供自己的ID，并且不同的线程在内部调用访问器函数时都应该能够比较快速地查找到正确的缓存空间。同时缓存空间只会被自己读写，但是读写频率较高，从性能角度来说，应该尽量避免不同线程的缓存空间在分别的读写中发生硬件的缓存一致性开销。
除了这样一个主要依赖缓存空间的方案，是否还有其他方案呢？

### 更新事项 v1.4.4
针对 v1.4 各功能的设计需求，我们对 v1.3 中已成型的设计内容进行了补充和修改，同时将池结构链表化、为下一步的扩展做准备，本更新即为此类调整的汇总。
1. zc_block_header_t中的padding启用为lut_entry_count。
2. 删去写入者的伴随守卫及其在内存块中占用的空间。
3. 明确会调用消息接口的API，精简数量、严格保证由消息管线传输的各类设置信息的使用不会导致内部错误，尤其是避免在持有块期间改变任何设置。
4. 原设计中writer_ref、reader_ref、reader_visited为原子变量，但是由于将其数组化分离之后，不再需要原子了，即不同线程会去修改不同的字段不会冲突，也不需要强求更新时阻止清理者读取旧的数据，这个延迟是可以接受的，取消这里的原子声明以允许更多的优化自由度。
4. 正式将内存池的512一行定名为“ZeroCore页表的一页”，增加16字节的页头包括8字节的内嵌3比特状态标识的行序号和8字节的前页地址，增加8字节的页尾即8字节的次页地址，将内存池的连续数组结构修改为链表结构，取消内存池的连续内存前提。
除此之外，在系统内部还需要一些内部可见、内部管理的元数据，记录下新的“内存池-内存段-内存页”三级内存的分布和使用情况，为后续适配NUMA乃至跨芯片、跨节点的分布式性能优化做基础，以及提供跨页内存块的连续性优化、内存段和内存页排序优化等运行时优化。
5. Zora的设计和实现中我们仍然应该把性能放在第一位，但是也需要在各个环节、层次提供安全校验的能力。
比较安全的API就是只需ID的，这个路径的安全性非常高，这个路径主要需要进一步优化性能，尽可能缩减直接的CPU计算开销，和接下来着重进行的适配缓存预取、分支预测等现代CPU为提高性能的优化，不破坏用户代码的分支预测、不预取多余的数据、不把用户数据挤出缓存、减少寄存器之间的拷贝。
相对危险的API是依赖handle的，这个路径的安全威胁现在集中在写者的恶意乱码写入。首先，handle本身要有适当的牢固性，用于校验的位数量应该恰当、密钥的更新频率应该恰当；其次，依赖handle的接口也需要依赖ID，而ID是天然对于线程身份敏感的，如果是伪造的ID，那直接比对Zora线程缓存中的ID就可以知道了，如果是独立的攻击线程，那它根本就没有Zora线程缓存，对于非注册攻击者的防御性足够高；最后，即使攻击者以极低的概率猜对了handle的校验位，然后要求了一个随机的地址，这个地址一个方面可能都不在作为用户进程的ZeroCore的合法地址空间里，另一方面也几乎不可能通过后续的强类型写入校验，同时还可以通过检验（正常来说那个位置应当是）本页页头和上页页尾的两个地址数值是否对应；由于handle对每个写者是分别加密的，底层的内存块之间也是逻辑上分离的，也几乎不可能两个攻击者线程合作攻击。不过handle内仍然至少需要保留版本号校验位，防止导致UAF的重放攻击。
6. 在增加了一系列逻辑之后，重新梳理内部线程的职能和数据结构，为下一步的内部性能优化做准备。

### 更新事项 v1.4.5
本次更新是完善文档中的TODO内容。
1. 针对 `1.2 内存段` 的 `<TODO>`：内存段元数据结构与动态管理机制
为支持“池-段-页”三级结构及未来 NUMA/跨节点优化，内存段需携带完整元数据。内存段是系统管理优化的主要单位，需要记录自身的编号、长度（下属页数）、下属页地址、下属页使用统计、段使用统计（包括上次遍历使用率、上次遍历块均长度、上次遍历块均使用时长估计、上次遍历写入者统计、上次遍历读取者统计等）、硬件亲和性统计等数据。同时需要实现内存段的运行时新增、锁定和释放三个内部接口。
2. 针对 `1.3 内存页 → 管理逻辑` 的 `<TODO>`：内存页运行时硬件优化支持
利用现代CPU特性（如预取提示）提升连续访问性能，包括获取块的API在前期对下一访问优先级的块和资源（如对应写入者的工作空间）的预取提示。
3. 针对 `1.6 系统线程简述` 和 `六、清理者及其内部协作` 的 `<TODO>`：系统线程职责与协作模型重构
考虑日益繁杂的内部线程职责，是按照工作函数指针数组将各类职责注入数量若干的平行的系统线程，还是将各类职责分别安排给不同的内部线程？我倾向于前者，并且我希望在未来采用分段负责的形式，即一组系统线程负责一组物理上相邻的内存段。在新增内存页结构作为最小单位之后，系统线程应该改为按照页的顺序遍历，但是块清理逻辑不需过多改变，这里就需要用到页头的页状态标识，识别块的起点，然后根据块的header计算块跨越的页数量，顺序遍历中间各页，还需要考虑对跨页DTTA的清理。
明确各系统职能（清理者、优化器、看门狗、密钥轮换器）的工作逻辑和生命周期，明确各系统线程的协作方式，完善 MessageRing 内部消息类型枚举。
4. 针对 `2.3 线程缓存全局数组 → 分配逻辑` 的 `<TODO>`：线程缓存初始化逻辑完善
修复函数签名，为写入者和读取者提供两个平行的版本。当前绑定在线程的资源包括线程缓存和线程工作空间两个部分，实现一个统一的“线程资源初始化API”，先初始化缓存，然后在进行到给工作空间指针赋值时内部调用初始化工作空间的接口，线程缓存的指针作为参数传入；在进行到给密钥赋值时内部调用硬件/操作系统提供的随机数生成器生成第一个密钥。
5. 针对 `3.3 类型描述符串` 的 `<TODO>`：DTTA 跨页存储支持
当DTTA区域超过当前页剩余空间时，支持将类型描述符串延续到下一页。当前已经提供了0xC0 类型流换页符作为0x00 END的修饰扩展版本，还需实现寻页、抢占、页头标注、系统优化提示等逻辑。
6. 针对 `八、数据访问 API` 的 `<TODO>`：数据访问 API 文档结构优化
详细介绍每类 API 的设计意图、与 Zora 的交互逻辑（如 handle 解密、版本校验）、与类型系统的交互逻辑（如类型冲突检测、描述符解析）、通用安全校验流程（权限、边界、状态机）相关重要内容。
7. 针对 `8.2 数据读取 API` 和 `8.3 辅助 API` 的 `<TODO>`：写入者读取和辅助接口
为写入者提供与读取者完全对称的读取和辅助 API，仅将参数 `reader_id` 替换为 `writer_id`。
8. 针对 `九、错误码` 的 `<TODO>`：内部错误码标准化
全局搜索内部函数，确保返回值类型已替换为 `zc_internal_result_t` 并正确映射。
