ZeroCore设计文档（v0）

### 一、设计核心思想总结

ZeroCore是一个**以共享内存池为中心**的实时流处理系统，其核心思想是通过**无锁同步**、**减少抽象层**和**精细的状态机**来最大化性能和确定性。其主要特点叙述如下：

1.  **三大角色职责分离**：
    *   **写入者**：获取空闲内存块、填充数据、标记就绪。具体来说，写入者按优先级查找空闲块，优先级顺序为：池首 > 缓存地址及其向后遍历（偏移量在阈值内且后向邻接块可用时优先） > 清理者指导地址。当发生地址跳跃（不连续使用后向邻接块而是跳跃到其他块）时，在工作空间展示跳跃到的地址（LastJumpingDestination）。写入者在尝试获取一个块之前，检查块的header中状态标识是否为`FREE`且写入者和读取者引用位图是否为全0，如果是则说明块可用，将引用位图对应位置位并重新将状态标识CAS为`FREE`；然后再次检查位图，如果有其他位也被置位说明陷入竞态，以各自在位图中的次序为优先顺序，如果自己不是第一优先位则检查是否有其他可选位置并退出竞争将位图对应位清零，如果陷入无内存可用的状态则向清除者发送消息，等待其回信可用地址。当写入者成功获取一个可用空闲块时，若其所需的大小小于块大小，则需要为剩下的部分新增一个header来标注剩余的小空闲块的情况，如果剩余长度不足一个header则不做分割，当成自己使用了这个空闲块的全部大小。为提高缓存性能、减少一些奇怪的边界情况，所有块大小至少向上取整为512的倍数。每当写入者获取一个内存块，写入者在其工作空间缓存这个内存块的偏移量，当下次使用了其他内存块取消了对这个偏移量的缓存时，写入者需先回到缓存的内存块header中将写入者引用位图的对应位清零。写入者写入完成后将其状态标识改为`USING`。写入时需在header中记录身份token并更新时间戳。
    *   **读取者**：发现、获取并处理就绪的数据块。具体来说，读取者利用写入者的顺序写入倾向和跳跃标识，为每个写入者缓存上次读取的内存块偏移量，先检查缓存地址及其后向邻接块，如果不正确再检查LastJumpingDestination标识，可能存在的因写入者突发频繁跳跃而遗漏的内存块由清理者通过时间戳和读取者访问记录位图识别并向对应的读取者发送消息，实现尽力而为的FIFO。检查的项目包括块状态标识为`USING`、读取者访问记录位图中自己的bit未置位、身份token匹配当前订阅流。读取时分别将读取者访问记录位图和读取者引用位图的对应位置位。类似于写入者，读取者引用位图也是在取消缓存时将对应位置零。
    *   **清理者**：回收处理完毕的内存块、维护内存池连续性、实施预防性背压应对并提供指导信息。具体来说，清理者每次从池首开始按块遍历，当遇到一个标识为`USING`、读取者访问记录位图显示所有该读取的读取者都已经读取、写入者和读取者引用位图为全0的内存块，则说明这个内存块可以被清理，将状态标识更新为`CLEAN`；但是仍然继续遍历，直到遇到最近一个不可被清理的内存块；然后将中间经过的内存块清理、合并为一个空闲块。另外，当遍历到一个标识为`FREE`、位图全0的空闲块时，缓存偏移量并继续遍历；如果其后邻接了另一个空闲块，则将后续空闲块的标识CAS为`CLEAN`，直到遇到非空闲块或CAS失败；然后回到缓存的块检查其状态是否发生改变，根据是否改变决定合并时是否包括缓存的块，如果试图包括则也需要将标识CAS为`CLEAN`。遍历过程中可以很容易地累加计算出内存池的负载量并查看到偏移量最大的内存块，清理者可以根据这两个数据动态调整内存池大小，实现预防性背压处理；扩容或减容时不可对前序内存迁移，只可尝试原地操作，这个功能可以关闭以防止部分场景下操作系统或硬件带来预期外的情况。清理者还需要在合并出一个偏移量在中部的大空闲块时通知写入者，包括向发信的写入者回信以及在自己的工作空间中展示，在工作空间中展示的可用地址即清理者指导地址。如果内存池较大、工作线程较多，可以有多个清理者按照一定间隔并行工作。

2.  **无锁同步基石**：
    *   通过数据块Header中的**原子状态标识**（`FREE`, `USING`, `CLEAN`）和**原子位图**（写入者引用位图、读取者引用位图、读取者访问记录位图）来协调多线程访问。（**不过在前面的角色叙述中状态标识是CAS的，从性能和可靠性两个角度，具体如何处理？**）
    *   通过**工作空间**（每个线程独立可写、全局可读的内存区域）来交换元数据（如心跳、地址、消息），避免了集中式的、需要加锁的状态管理。其中消息的发送也是写在自己的工作空间中的特定位置，由接收方主动检查。除了具体的消息列表是长度可变的，工作空间的主要内容（包括消息的元数据，即最新版本号和消息列表头指针，每个接收方各一个）都是固定结构的。

3.  **高效的内存管理**：
    *   **内存池预分配**：消除运行时实时分配、释放的开销和碎片。
    *   **零拷贝**：数据始终位于内存池中，线程间只传递指针或索引。
    *   **合并机制**：清理者主动合并相邻空闲块，形成大块连续内存，提高读写效率。

4.  **智能的寻址策略**：
    *   清理者提供**指导地址**，动态引导写入者使用内存池中部的空闲块，进一步优化布局。清理者的指导地址算法还可以进一步研究，使其在全局、长期上更加高效。

5.  **尽力而为的FIFO**：
    *   利用写入者的**顺序写入倾向**和**时间戳**，在读取端通过**本地顺序读取**和**清理者通知**的机制，尽可能实现先进先出的数据处理，以满足音视频流的时序要求。

6. **精细的状态机**
    *   **`FREE`标识对应的所有可能状态**：首先，一个确实可用的块会标记为`FREE`；其次，一个块被写入者尝试获取甚至陷入竞态时，仍然保留`FREE`标识，但是其写入者引用位图不全0。
    *   **`USING`标识对应的所有可能状态**：首先，一个写入完成的块会被标记为`USING`；其次，读取者读取时不改变`USING`标识；再次，等待回收的块仍然保留`USING`标识，但是其写入者引用位图和读取者引用位图全为0且读取者访问记录位图匹配读取者注册列表值；最后，回收处理中的块仍然保留`USING`标识。
    *   **`CLEAN`标识对应的所有可能状态**：首先，一个正在被清理的块会被标记为`CLEAN`；其次，待合并的块会被标记为`CLEAN`以声明其已被一个清理者持有。
    *   **`FREE`向`USING`的转换条件**：有且仅有唯一的写入者完成写入时，由这个写入者实施。
    *   **`USING`向`CLEAN`的转换条件**：有且仅有清理者开始清理时，由这个清理者实施。
    *   **`CLEAN`向`FREE`的转换条件**：有且仅有清理者完成清理时，由这个清理者实施。
    *   **`FREE`向`CLEAN`的转换条件**：有且仅有清理者决定合并时，由这个清理者实施。

7. **严格的行为边界**
    *   **可以新增一个header（即划分内存块）的角色**：有且仅有写入者。
    *   **可以删除一个header（即合并内存块）的角色**：有且仅有清理者。

---

### 二、需要细化和改进的关键点

尽管设计非常先进，但在具体实现中，以下几个方面的细节至关重要，处理不当会导致性能下降或难以调试的Bug。

#### 1. 状态机的严谨性与错误处理
*   **问题**：无锁编程极度依赖状态机的严谨性。一个状态转换错误或遗漏都可能导致死锁、数据丢失或崩溃。
*   **细化建议**：
    *   **正式定义状态转换图**：为每个状态（FREE, IN_USE_BY_WRITER, READY, IN_USE_BY_READER）明确列出所有合法的前置状态和转换操作。例如，`READY`状态只能由`IN_USE_BY_WRITER`转换而来，只能转换为`IN_USE_BY_READER`。
    *   **引入超时与心跳机制**：如果一个数据块长时间处于`IN_USE`状态（例如，由于线程崩溃），需要有一个监控机制（“看门狗”）来强制回收该块，防止内存池耗尽。这需要各线程在工作空间定期更新心跳。

#### 2. 背压传播与流量控制
*   **问题**：当读取者/清除者速度跟不上写入者时，内存池会被填满。写入者该如何处理？忙等（空转消耗CPU）？丢弃数据？还是通知上游减速？
*   **细化建议**：
    *   **实现明确的背压信号**：当写入者多次尝试找不到空闲块时，应触发背压机制。这可以通过一个无锁环形队列向数据源发送“减速”信号，或者设置一个信号量/条件变量让写入者休眠片刻。
    *   **动态丢弃策略**：对于实时性要求极高的场景（如直播），可以定义策略（如丢弃最老的未处理帧），确保处理最新的数据。

#### 3. 内存序的正确使用
*   **问题**：这是无锁编程中最容易出错的地方。原子操作的`memory_order`选择错误，会导致一个线程的写操作结果对另一个线程不可见，从而出现违反直觉的状态不一致。
*   **细化建议**：
    *   **仔细规划内存序**：对于状态标志的修改，通常需要使用`memory_order_release`（写入端）和`memory_order_acquire`（读取端）配对，确保状态改变后，该状态之前的所有数据写入都对读取线程可见。
    *   **寻求静态验证工具**：使用像`ThreadSanitizer`这样的工具来检测数据竞争。在代码审查中，对每一个原子操作的内存序进行重点检查。

#### 4. 清理者合并操作的原子性与安全性
*   **问题**：合并两个相邻的`FREE`块并非原子操作。清理者在检查第二个块的状态后、修改第一个块的头信息前，可能有写入者突然获取了第二个块，导致错误。
*   **细化建议**：
    *   **使用CAS链进行合并**：清理者需要尝试以原子方式“锁定”两个相邻块。例如，先将第二个块的状态CAS为一种特殊的`MERGING`状态，然后再修改第一个块的长度。如果对第二个块的CAS失败，则放弃本次合并。这增加了复杂性，但保证了安全。

#### 5. 读取者FIFO的保证度
*   **问题**：依赖地址顺序和清理者通知来实现FIFO是“尽力而为”的，在写入者频繁跳跃时，读取者可能仍需遍历查找，破坏了实时性。
*   **细化建议**：
    *   **为每个流维护一个无锁队列**：这是最有效的改进，但引入了“新结构”。这个权衡是值得的。可以为每个写入者或每个数据流维护一个无锁的单生产者-多消费者链表队列，存放指向`READY`块的指针。写入者完成后将指针入队，读取者从队首获取。这从根本上保证了FIFO，且性能极高。这是对您“避免新结构”原则的合理突破。

#### 6. 性能优化与硬件亲和性
*   **问题**：在NUMA架构（多路CPU服务器）上，随意分配内存池可能导致远程内存访问，带来巨大延迟。
*   **细化建议**：
    *   **NUMA感知的内存分配**：将内存池分配在它与最常访问它的线程（写入者、读取者）所在的同一个NUMA节点上。
    *   **线程绑定**：将相关的写入者、读取者、清除者线程绑定到特定的CPU核心上，提高缓存命中率。

