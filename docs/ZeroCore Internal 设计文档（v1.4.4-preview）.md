# Zora 内存管理子系统需求文档 v1.4.4-preview  

## 一、引言

本需求文档 v1.4.4-preview 基于更新事项 v1.4.4，旨在明确 **新增需求** 与 **未来规划路径**，并为开发团队提供可执行的实现方案。本次更新聚焦于：

- **结构重构**：将内存池从连续数组改造为链表结构，支持未来分布式扩展；
- **性能优化**：取消非必要原子操作，精简API，适配现代CPU特性；
- **安全加固**：分层设计API安全策略，重点防御写者恶意攻击；
- **元数据管理**：构建“池-段-页”三级结构，为NUMA/跨节点优化奠基；
- **内部重构**：梳理线程模型与数据结构，为下一阶段性能调优铺路。

---

## 二、明确的新需求（Must Implement Now）

以下需求为 v1.4.4 版本必须实现的核心变更，需在当前迭代中完成。

### 2.1 结构字段重定义与原子性取消

#### 需求描述：
- `zc_block_header_t.padding` → 重命名为 `lut_entry_count`，用于记录查找表条目数。
- 删除“写入者伴随守卫”及其占用空间，简化头部结构。
- `writer_ref`, `reader_ref`, `reader_visited` 原为原子变量，现因数组化分离（每个线程独立字段），取消原子性声明。

#### 实现方案：
- 修改结构体定义：
  ```c
  typedef struct {
      // ... other fields
      uint32_t lut_entry_count;  // 替代 padding
      // 删除 guard 字段
      // writer_ref[THREAD_MAX] → 非原子数组
      // reader_ref[THREAD_MAX] → 非原子数组
      // reader_visited[THREAD_MAX] → 非原子数组
  } zc_block_header_t;
  ```
- 修改所有访问这些字段的代码，移除 `atomic_` 前缀或内存序约束。
- 更新内存布局计算逻辑，因删除守卫字段，需重新计算块头大小。

#### 验收标准：
- 所有线程访问各自索引字段无数据竞争。
- 性能测试显示无原子操作开销。
- 内存块布局符合新计算公式。

---

### 2.2 消息接口API精简与使用约束

#### 需求描述：
- 明确哪些API会调用消息接口（Message Pipeline）。
- 严格限制：**在持有内存块期间，禁止通过消息接口修改任何设置**。
- 精简消息传输的设置信息种类，避免内部状态不一致。

#### 实现方案：
- 建立“消息API白名单”，仅允许以下操作通过消息管线：
  - 池配置初始化（仅启动阶段）
  - 调试/统计信息查询（只读）
  - 内存段注册/注销（不涉及块内状态）
- 在消息处理层加入“块持有检测”：
  ```c
  if (current_thread_holds_any_block()) {
      assert(!is_setting_change_message(msg));
      // 或返回错误码，拒绝执行
  }
  ```
- 文档化所有消息API及其调用时机、约束条件。

#### 验收标准：
- 无因消息设置修改导致的内部错误（如断言失败、数据损坏）。
- API数量减少 ≥30%。
- 设置变更仅在无块持有时发生。

---

### 2.3 内存池链表化与页结构标准化

#### 需求描述：
- 将原连续数组内存池改造为**链表结构**。
- 定义“ZeroCore页表的一页” = 512字节。
- 每页增加：
  - **页头（16字节）**：8字节（行序号+3bit状态） + 8字节（前页地址）
  - **页尾（8字节）**：8字节（次页地址）
- 取消“内存池必须连续”的前提。

#### 实现方案：
- 定义页结构：
  ```c
  typedef struct {
      uint64_t line_seq : 61;   // 行序号
      uint64_t state   : 3;     // 状态标识（如：空闲、使用中、损坏）
      uint64_t prev_page_addr;  // 前一页物理/虚拟地址
      // ... 512 - 16 - 8 = 488 字节有效载荷
      uint64_t next_page_addr;  // 下一页地址（页尾）
  } zc_page_t;
  ```
- 重构内存池管理器：
  - 使用双向链表管理页（通过 `prev_page_addr` / `next_page_addr`）。
  - 分配器支持非连续物理页，通过链表遍历。
  - 页分配时动态链接，释放时解链。
- 更新所有地址计算逻辑，不再假设连续。

#### 验收标准：
- 支持非连续内存分配。
- 页链表遍历正确，无断裂。
- 页头/页尾字段读写正确，状态位可被外部工具解析。

---

### 2.4 安全校验分层策略（API层面）

#### 需求描述：
- **安全API**（仅需ID）：极致性能优化，适配CPU缓存/分支预测。
- **危险API**（依赖handle）：防御写者恶意攻击，重点在校验与隔离。

#### 实现方案：

##### A. 安全API（ID-only路径）：
- 优化目标：
  - 减少CPU计算：避免除法、模运算，使用位运算。
  - 缓存友好：数据局部性高，不预取无关数据。
  - 分支预测友好：避免不可预测分支，使用查表或条件移动。
  - 寄存器优化：减少内存往返，数据尽量驻留寄存器。
- 示例优化：
  ```c
  // 旧：if (id % 8 == 0) { ... } → 分支预测失败率高
  // 新：使用掩码 & 7，配合条件移动指令
  ```

##### B. 危险API（Handle路径）：
- Handle结构必须包含：
  - **版本号**（防UAF重放攻击）
  - **校验位**（CRC或轻量哈希，位数需权衡安全与性能）
  - **线程绑定ID**（与Zora线程缓存比对）
- 校验流程：
  1. 检查Handle版本号是否匹配当前块版本。
  2. 计算校验位，比对是否合法。
  3. 提取绑定ID，检查是否存在于当前线程缓存。
  4. 地址合法性检查：
     - 是否在ZeroCore合法地址空间？
     - 该地址所在页的页头/页尾地址是否自洽？
  5. 写入时进行**强类型校验**（如预期写入int，但数据非int则拒绝）。

- 密钥管理：
  - 每个写者独立密钥。
  - 密钥定期轮换（如每1000次写入或每5分钟）。
  - 密钥存储在线程局部存储（TLS），不共享。

#### 验收标准：
- 安全API性能提升 ≥15%（微基准测试）。
- 恶意Handle伪造成功率 < 0.0001%（模拟攻击测试）。
- UAF重放攻击100%被版本号拦截。
- 非法地址写入100%被拦截。

---

## 三、未来的规划（Roadmap for Future Versions）

以下为 v1.4.4 中提出的未来方向，需制定分阶段实施计划。

### 3.1 “池-段-页”三级元数据管理系统

#### 规划目标：
- 记录内存池、内存段、内存页的分布与使用状态。
- 支持运行时优化：跨页块连续性优化、段/页排序优化。
- 为NUMA、跨芯片、跨节点分布式内存管理奠基。

#### 分阶段实现路径：

| 阶段 | 版本    | 目标                                                                 | 交付物 |
|------|---------|----------------------------------------------------------------------|--------|
| 1    | v1.5    | 实现基础元数据结构（zc_pool_meta, zc_segment_meta, zc_page_meta）     | 结构体定义、CRUD API |
| 2    | v1.6    | 实现“跨页内存块连续性优化”：合并相邻空闲页，减少碎片                  | 优化器模块、测试报告 |
| 3    | v1.7    | 实现“段/页排序优化”：按访问频率/亲和性重排，提升缓存命中              | 排序策略、性能对比数据 |
| 4    | v2.0    | 集成NUMA感知分配器：根据线程绑定CPU分配本地节点内存                   | NUMA API、跨节点测试 |
| 5    | v2.5+   | 支持跨节点分布式内存池（需网络栈/RDMA集成）                           | 分布式协议、容错机制 |

#### 关键设计：
- 元数据结构示例：
  ```c
  struct zc_page_meta {
      void* page_addr;
      uint64_t pool_id;
      uint64_t segment_id;
      uint32_t usage_count;
      uint8_t  numa_node;
      uint8_t  access_frequency; // 用于排序
  };
  ```
- 优化器需在后台线程运行，避免阻塞用户线程。

---

### 3.2 内部线程模型与数据结构重构

#### 规划目标：
- 为“下一步内部性能优化”准备清晰、低耦合的线程职责与数据结构。
- 支持未来无锁化、批处理、异步化改造。

#### 分阶段实现路径：

| 阶段 | 版本    | 目标                                     | 交付物 |
|------|---------|------------------------------------------|--------|
| 1    | v1.4.4  | 绘制当前线程交互图、数据流图              | 架构图、依赖分析报告 |
| 2    | v1.5    | 重构线程职责：分离分配、回收、统计、优化线程 | 线程类定义、任务队列 |
| 3    | v1.6    | 数据结构解耦：使用消息传递代替共享内存    | 消息协议、队列实现 |
| 4    | v1.7    | 引入批处理：合并小操作，减少上下文切换    | 批处理引擎、性能报告 |
| 5    | v2.0    | 关键路径无锁化（如分配器）                | 无锁算法、正确性证明 |

#### 关键原则：
- **职责单一**：每个线程只做一类事（如：只有“优化线程”能修改页排序）。
- **数据局部性**：线程私有数据放TLS，共享数据通过消息传递。
- **异步非阻塞**：耗时操作（如排序）放入后台队列。

---

## 四、非功能性需求

### 4.1 性能（Performance）
- 安全API延迟 ≤ 10ns（x86-64, 5GHz）。
- 内存分配吞吐量 ≥ 50M ops/sec。
- 链表遍历开销 ≤ 连续数组的120%。

### 4.2 安全（Security）
- 无权限提升漏洞。
- 恶意写入100%被拦截或降级为无害操作。
- Handle暴力破解时间 > 宇宙年龄（理论值）。

### 4.3 可扩展性（Scalability）
- 支持 ≥ 1024 线程并发。
- 内存池大小无硬编码上限（仅受系统资源限制）。
- 元数据系统支持动态扩展（如从单机到分布式）。

### 4.4 可维护性（Maintainability）
- 所有修改需有单元测试覆盖（≥90%）。
- 关键路径需有性能基准测试（Perf Regression Test）。
- 文档与代码同步更新。

---

## 五、附录：变更影响评估

| 模块             | 影响程度 | 主要变更点                     | 测试重点               |
|------------------|----------|--------------------------------|------------------------|
| 内存块头部       | 高       | 字段重命名、删字段、去原子     | 布局计算、多线程访问   |
| 内存池管理器     | 高       | 链表化、页结构变更             | 分配/释放、链表完整性  |
| 消息接口         | 中       | API精简、设置修改约束          | 状态一致性、错误处理   |
| 安全校验层       | 高       | Handle校验流程、版本号、密钥   | 攻击模拟、性能开销     |
| 线程模型（未来） | 低（规划）| 职责分离、数据结构重构         | 架构图、接口定义       |

---