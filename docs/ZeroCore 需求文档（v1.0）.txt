# ZeroCore 需求文档（v1.0）

> **目标**：构建一个以共享内存池为中心、无锁同步、低延迟、高吞吐、可热重载、跨平台的流处理内核引擎，支持音视频、网络封包、传感器数据等实时场景。

---

## 一、系统级接口需求

### 1.1 初始化与销毁

| 接口名 | 参数 | 返回值 | 说明 |
|--------|------|--------|------|
| `zc_init` | `config: ZC_Config*` | `ZC_Result` | 初始化内存池、工作空间、线程局部存储。支持从配置结构体传入池大小、块对齐、心跳间隔、最大线程数等。 |
| `zc_destroy` | `void` | `ZC_Result` | 安全关闭：等待所有块回收、清理线程退出、释放内存。支持超时强制销毁。 |

> ✅ 支持多次初始化/销毁（需互斥锁保护全局状态）  
> ✅ 支持“软重启”：不清空内存池，仅重置状态机（用于热重载）

---

### 1.2 配置结构体（`ZC_Config`）

```c
typedef struct {
    size_t pool_size;           // 内存池总大小（字节），必须 >= 4MB
    size_t block_align;         // 块对齐大小，默认512，必须是2的幂且>=64
    size_t max_threads;         // 最大支持的写入/读取线程总数
    size_t heartbeat_interval;  // 心跳间隔（纳秒），默认1e8（100ms）
    size_t msg_queue_size;      // 每线程消息队列长度，默认16
    bool   enable_cleaner;      // 是否启用清理者线程
    size_t cleaner_count;       // 清理者线程数（默认1，最大8）
    size_t cleaner_stride;      // 清理者并行时的步进偏移（字节），默认pool_size / cleaner_count
    char   reserved[64];        // 预留扩展字段，清零
} ZC_Config;
```

---

### 1.3 监控与统计接口

| 接口名 | 参数 | 返回值 | 说明 |
|--------|------|--------|------|
| `zc_stats_snapshot` | `out: ZC_Stats*` | `void` | 原子快照当前状态：空闲块数、使用中块数、合并次数、背压触发次数、跳跃次数等。 |
| `zc_dump_pool` | `FILE* fp` | `void` | 调试用：输出所有块状态、偏移、大小、时间戳、位图（仅DEBUG模式有效） |
| `zc_set_log_level` | `level: ZC_LogLevel` | `void` | 设置日志级别（ERROR/WARN/INFO/DEBUG） |
| `zc_register_hook` | `event: ZC_HookEvent, cb: ZC_HookCallback` | `ZC_Result` | 注册钩子（如块分配前、回收后、跳跃发生时） |

---

### 1.4 热重载支持

| 需求 | 说明 |
|------|------|
| 动态增删工作线程 | 支持运行时注册/注销写入者、读取者线程，无需重启引擎。线程ID可复用。 |
| 配置热更新 | 支持运行时更新部分配置（如心跳间隔、清理者数量），通过 `zc_update_config` 接口。 |
| 状态保留重启 | 支持“软重启”：不清空数据，仅重置控制结构，用于策略热替换。 |

> ✅ 所有热重载操作必须线程安全，使用无锁队列或RCU风格更新。

---

## 二、写入者（Writer）接口需求

### 2.1 注册与注销

| 接口名 | 参数 | 返回值 | 说明 |
|--------|------|--------|------|
| `zc_writer_register` | `token: uint32_t, out_id: uint32_t*` | `ZC_Result` | 注册写入者，分配唯一writer_id，绑定token（用于数据流标识）。 |
| `zc_writer_unregister` | `writer_id: uint32_t` | `ZC_Result` | 注销写入者，释放其引用的所有块（强制回收），清空其工作空间。 |

> ✅ writer_id 由系统分配，范围 [0, max_threads)，可复用。  
> ✅ 支持“优雅注销”：等待当前写入完成后再回收。

---

### 2.2 写入流程接口

| 接口名 | 参数 | 返回值 | 说明 |
|--------|------|--------|------|
| `zc_writer_acquire_block` | `writer_id, size: size_t, timeout_ns: uint64_t` | `ZC_BlockHandle*` | 尝试获取至少`size`字节的空闲块。支持超时。失败返回NULL。 |
| `zc_writer_commit_block` | `handle: ZC_BlockHandle*` | `ZC_Result` | 提交写入，标记块为`USING`，更新时间戳。必须在acquire后调用。 |
| `zc_writer_cancel_block` | `handle: ZC_BlockHandle*` | `ZC_Result` | 取消写入，释放块引用（不清除数据，块状态回`FREE`）。用于写入失败或中断。 |

> ✅ `ZC_BlockHandle` 是不透明指针，内部包含header指针、偏移、大小、writer_id等。  
> ✅ acquire内部实现优先级寻址（池首 > 缓存 > 跳跃 > 清理者指导）。

---

### 2.3 消息与心跳

| 接口名 | 参数 | 返回值 | 说明 |
|--------|------|--------|------|
| `zc_writer_check_messages` | `writer_id: uint32_t, out_msgs: ZC_Message*, max_count: int` | `int` | 拉取清理者发来的消息（如CLEAN_HINT），返回实际消息数。 |
| `zc_writer_send_heartbeat` | `writer_id: uint32_t` | `void` | 更新工作空间中的心跳时间戳（通常由框架自动调用，也可手动触发） |

> ✅ 消息类型：  
> - `ZC_MSG_CLEAN_HINT`：清理者推荐写入地址  
> - `ZC_MSG_BACKPRESSURE`：背压警告，建议减缓写入  
> - `ZC_MSG_JUMP_ALERT`：频繁跳跃警告，建议重置缓存

---

## 三、读取者（Reader）接口需求

### 3.1 注册与注销

| 接口名 | 参数 | 返回值 | 说明 |
|--------|------|--------|------|
| `zc_reader_register` | `token_mask: uint32_t, out_id: uint32_t*` | `ZC_Result` | 注册读取者，分配reader_id，指定关注的token位掩码（支持多流）。 |
| `zc_reader_unregister` | `reader_id: uint32_t` | `ZC_Result` | 注销读取者，释放其引用块，清空工作空间。 |

> ✅ token_mask：bit N 置1表示关注token==N的数据流。

---

### 3.2 读取流程接口

| 接口名 | 参数 | 返回值 | 说明 |
|--------|------|--------|------|
| `zc_reader_poll_block` | `reader_id: uint32_t, timeout_ns: uint64_t` | `ZC_BlockHandle*` | 尝试获取下一个可读块（按FIFO尽力）。支持超时。 |
| `zc_reader_release_block` | `handle: ZC_BlockHandle*` | `ZC_Result` | 释放块引用，标记本reader已访问。必须在poll后调用。 |

> ✅ poll内部实现：检查缓存偏移 → 检查跳跃目标 → 全局扫描（fallback）  
> ✅ 自动处理清理者推送的“遗漏块”消息

---

### 3.3 消息与心跳

| 接口名 | 参数 | 返回值 | 说明 |
|--------|------|--------|------|
| `zc_reader_check_messages` | `reader_id: uint32_t, out_msgs: ZC_Message*, max_count: int` | `int` | 拉取清理者消息（如MISSING_BLOCK_HINT） |
| `zc_reader_send_heartbeat` | `reader_id: uint32_t` | `void` | 更新心跳 |

> ✅ 消息类型：  
> - `ZC_MSG_MISSING_BLOCK`：清理者通知可能遗漏的块偏移  
> - `ZC_MSG_STREAM_IDLE`：某token流长时间无数据

---

## 四、清理者（Cleaner）接口需求

### 4.1 控制接口

| 接口名 | 参数 | 返回值 | 说明 |
|--------|------|--------|------|
| `zc_cleaner_start` | `cleaner_id: uint32_t` | `ZC_Result` | 启动指定清理者线程（若未创建则创建） |
| `zc_cleaner_stop` | `cleaner_id: uint32_t` | `ZC_Result` | 停止清理者线程（优雅退出） |
| `zc_cleaner_set_strategy` | `cleaner_id, strategy: ZC_CleanStrategy*` | `ZC_Result` | 设置清理策略（可热替换） |

---

### 4.2 策略插件接口（`ZC_CleanStrategy`）

```c
typedef struct {
    const char* name;
    void (*init)(void* ctx);
    void (*destroy)(void* ctx);
    uint64_t (*select_clean_start)(void* ctx, MemoryPool* pool); // 选择遍历起点
    bool (*should_merge)(void* ctx, BlockHeader* a, BlockHeader* b); // 是否合并相邻FREE块
    uint64_t (*suggest_write_address)(void* ctx, MemoryPool* pool, uint32_t writer_id); // 推荐写入地址
    void* ctx; // 用户上下文
} ZC_CleanStrategy;
```

> ✅ 默认策略：`zc_default_clean_strategy`  
> ✅ 支持用户自定义策略动态加载

---

## 五、扩展点与插件接口

### 5.1 寻址策略插件（写入者用）

```c
typedef struct {
    const char* name;
    void (*init)(void* ctx);
    void (*destroy)(void* ctx);
    uint64_t (*find_free_block)(void* ctx, MemoryPool* pool, size_t size, uint32_t writer_id);
    void* ctx;
} ZC_AllocStrategy;
```

> ✅ 默认：优先级寻址（池首>缓存>跳跃>清理者指导）  
> ✅ 可扩展：亲和性分配、大小匹配分配等

---

### 5.2 背压策略插件

```c
typedef struct {
    const char* name;
    void (*init)(void* ctx);
    void (*destroy)(void* ctx);
    bool (*should_throttle)(void* ctx, MemoryPool* pool, ZC_Stats* stats);
    void (*on_throttle)(void* ctx, uint32_t writer_id);
    void* ctx;
} ZC_BackpressureStrategy;
```

> ✅ 默认：基于空闲内存比例（<20%触发）  
> ✅ 可扩展：基于延迟、队列深度等

---

### 5.3 状态机钩子（Hook）

```c
typedef enum {
    ZC_HOOK_BEFORE_ALLOC,
    ZC_HOOK_AFTER_COMMIT,
    ZC_HOOK_BEFORE_CLEAN,
    ZC_HOOK_AFTER_MERGE,
    ZC_HOOK_ON_JUMP,
    // ... 可扩展
} ZC_HookEvent;

typedef void (*ZC_HookCallback)(ZC_HookEvent event, void* data, void* user_ctx);
```

> ✅ 用于调试、监控、AOP式扩展

---

## 六、热重载与动态配置需求

| 功能 | 接口 | 说明 |
|------|------|------|
| 动态增删线程 | `zc_writer_register/unregister`, `zc_reader_register/unregister` | 运行时安全调用 |
| 更新清理者策略 | `zc_cleaner_set_strategy` | 支持运行时切换 |
| 更新全局配置 | `zc_update_config(ZC_Config* new_cfg)` | 仅部分字段可热更新（如心跳、清理者数） |
| 软重启 | `zc_soft_restart()` | 重置所有状态机、清空工作空间、保留内存池数据 |

> ✅ 所有热重载操作必须保证：  
> - 无数据损坏  
> - 无死锁  
> - 低延迟（<1ms）  
> - 可回滚（失败时恢复原状态）

---

## 七、跨平台与可移植性需求

| 项目 | 要求 |
|------|------|
| 编译器 | 支持C11（`stdatomic.h`, `_Thread_local`） |
| CPU架构 | x86_64, ARM64（需保证原子操作和内存序） |
| OS支持 | Linux, Windows, macOS, FreeRTOS（预留抽象层） |
| 依赖库 | 无第三方依赖（仅系统调用） |
| 字节序 | 小端优先，大端需编译时定义`ZC_BIG_ENDIAN`并适配 |

> ✅ 平台相关代码封装在 `zc_platform.h` / `zc_platform.c`

---

## 八、非功能性需求

| 类别 | 要求 |
|------|------|
| 性能 | 单块分配/回收延迟 < 100ns（无竞争时） |
| 吞吐 | 支持百万级块/秒操作 |
| 延迟 | 99.9% 分位 < 1μs（P999延迟） |
| 确定性 | 无垃圾回收、无动态内存分配（运行时） |
| 安全性 | 无数据竞争、无死锁、状态机可恢复 |
| 可调试性 | 提供dump、hook、统计接口 |
| 可扩展性 | 插件化策略、钩子、多清理者 |
